tryItOut("if((-1)) { if (__proto__) const constructor = false, constructor = this; else {; }}\n");
tryItOut("/*for..in*/for(let constructor in ((eval)([\n<x><y/></x>])))var prototype;");
tryItOut("/*infloop*/while((__count__ =  '' )[(( /x/g )(@foo))])if(<x><y/></x>) ; else  if (3) {if((constructor)(this, @foo)) throw window }");
tryItOut("let __noSuchMethod__, x::__parent__;var __noSuchMethod__ = {}, __count__\n({}).__lookupGetter__\n");
tryItOut("export *;return *::*;");
tryItOut("/*infloop*/while(window /= <><x><y/></x></> .@x:: ({prop: prototype }))gc()");
tryItOut("/*for..in*/L:for(var __noSuchMethod__ in ((new Function)([15,16,17,18].map(((<y><z/></y> >> <><x><y/></x></>)).__defineSetter__, eval(\"<><x><y/></x></>\", <y><z/></y>))))){return undefined;/*infloop*/while((eval(\"/*for..in*/for(const __parent__ = __proto__ in ({a2:z2})) break L;\", [,,]))){ } }");
tryItOut("L: {}");
tryItOut("for(let y in []);");
tryItOut("if(*) { if (arguments) return;} else {}");
tryItOut("/*for..in*/M:for(const prop = *::* in ({})) {var __noSuchMethod__ = __iterator__; }");
tryItOut("for(let y in [5,6,7,8]) this.zzz.zzz;");
tryItOut("if(constructor = (typeof 3/0 :: <x><y/></x>) = null >>= this[<> </>.((<x><y/></x>.(1.2e3)))]) { if (prototype = __proto__.__iterator__) {}} else {switch((<x/>.@foo)) { default: ( /x/ );break; case ('haha'.split)(prop): const __parent__, __parent__ = <x><y/></x>; } }");
tryItOut("L:if(({prop: null, __noSuchMethod__:  /x/g  }) = (new <x><y/></x>(__parent__))) break ; else {(prop);return arguments; }");
tryItOut("M:if(constructor) {gc() }");
tryItOut("gc()");
tryItOut("if(__count__ = @foo.watch(\"__proto__\", Math.pow)) prop = ({a1:1}) else {return <x><y/></x>; } const __count__;");
tryItOut("export prop;\n/*infloop*/L:while(true)\n");
tryItOut("throw __parent__;");
tryItOut("/*for..in*/for(__iterator__.__parent__ in (((<x><y/></x>).call)(true))){__noSuchMethod__; }");
tryItOut("__count__ = __iterator__;");
tryItOut("const prototype;");
tryItOut("L: {gc() }");
tryItOut("export *");
tryItOut("yield __proto__ = __count__;");
tryItOut("/*\n*/throw prop;");
tryItOut("/*infloop*/for(<x><y/></x>; <x><y/></x>; #1=[#1#]) (<><x><y/></\rx></>);");
tryItOut("/*infloop*/while(<x><y/></x>){export __parent__;const __count__ = <x><y/></x>; }");
tryItOut("/*infloop*/while(return __parent__;.__lookupSetter__(\"__count__\")){return\n( '' );; }");
tryItOut("/*infloop*/for(var __iterator__ = __parent__ = window; setter = function(id) { return id }; <></> .. <x/>) yield arguments;\nyield;\n");
tryItOut("([,,]);");
tryItOut("__iterator__ = __noSuchMethod__;");
tryItOut("L: /*infloop*/do return __iterator__; while(-3/0);");
tryItOut("if((let (prototype = __iterator__ = #1#, __count__ = <x><y/></x>) (p={}, (p.z = <x><y/></x>)()))) {; } else  if (__noSuchMethod__%=<x><y/></x> && @foo) {let __count__; }");
tryItOut("*::*");
tryItOut("switch(function(id) { return id }) { default: /*for..in*/for(let prop = 1.2e3.* in  /x/ ) {<x><y/></x>; }\t/*for..in*/for(var __count__ in <\txxx {__parent__}={-1} />) return ((function(q) { return q; }).call(*, ));break; (this.__defineGetter__(\"prototype\", 'haha'.split).propertyIsEnumerable(\"prototype\"));break; /*for..in*/for(__noSuchMethod__ in (<x><y/></x>.@foo)) {M:if((window .@ .2)((<y><z/></y>.unwatch(\"__noSuchMethod__\")),  /x/g )) { if (typeof this) break ; else yield  '' ;} }case ([1,,]).__defineSetter__: __iterator__ = (new true())break; {}export prototype;case 0: M:if(<x><y/></x>) { if ((constructor = *::*)) {yield;const constructor; }} else {gc() }throw __noSuchMethod__\nbreak; break;  }");
tryItOut("{constructor;continue M; }");
tryItOut("return;");
tryItOut("if(eval(\"(* >> <x/>)\\n\", (new <y><z/></y>([z1,,] < @foo)))) { if (export __iterator__) {while(((this.__defineGetter__(\"constructor\", function  __noSuchMethod__ (constructor, __count__) { yield [,,z1] } ))) && 0)/*\n*/{const __parent__ = <x><y/></x>; } } else {;; }}");
tryItOut("Math.sin; const __noSuchMethod__;");
tryItOut("if((<x/>.__defineGetter__(\"({ __count__: prop })\", (1 for (x in []))))) {yield; } else  if (__proto__ = yield false;) return <x/>;");
tryItOut("with({}) with({}) { for(let y in []); } ");
tryItOut("let(prop) ((function(){(<x><y/></x>);})());");
tryItOut("/*for..in*/for(let [__parent__, __parent__] = {} in false) {var constructor, __proto__; }");
tryItOut("if(window) { if (<><x><y/></x></>) yield; else {yield #1=[#1#]; }}\n");
tryItOut("L: {{}L:while((\n__noSuchMethod__.(prop)) && 0){{export __parent__; } } }");
tryItOut("return;");
tryItOut("with({__count__.__iterator__: typeof \n /x/ }){L: {yield;let prop = <><x><y/></x></>, __noSuchMethod__ =  \"\" ; }yield @foo.@*; }");
tryItOut("/*for..in*/for(var <x/> in ((<><x><y/></x></>)(<y><z/></y>.hasOwnProperty(\"__parent__\")))){var constructor, __proto__ = <><x><y/></x></>;{} }");
tryItOut("{with({([constructor = {} if (<><x><y/></x></>)]): <xxx>{__proto__}</xxx>}){export __proto__;export constructor; }export prototype; }");
tryItOut("L: {return <x/>; }");
tryItOut("if((@foo.prototype)) {return undefined; }");
tryItOut("for(let y in [])\n");
tryItOut("return window;");
tryItOut("L: gc()");
tryItOut("return");
tryItOut("__count__ = function::__count__;");
tryItOut("throw constructor;");
tryItOut("let ( /x/g  = 'fafafa'.replace(/a/g, ((new Function(\"let __noSuchMethod__, __iterator__;\"))).call)) { export __noSuchMethod__; }");
tryItOut("/*infloop*/for(var [({ __count__: prototype })] = <><> </></>; prototype; [1]) {throw prototype;return  /x/ ; }return;\n/*for..in*/for(const [prop, __iterator__] = __count__.__count__ = <y><z/></y> in false) gc()\n");
tryItOut("/*infloop*/do {export *; } while((__parent__.__count__ setter= function(q) { return q; }));");
tryItOut("(__noSuchMethod__)");
tryItOut("L: yield;");
tryItOut("L:with({__proto__: window}){throw StopIteration;do {__proto__;({}); } while((let (__iterator__ = -0) case 2: break; ) && 0); }");
tryItOut("{export *;(<x/>)__iterator__ = null.hasOwnProperty(\"__noSuchMethod__\"), prop.watch }");
tryItOut("return;");
tryItOut("switch(new (null.\tconstructor =  /x/g )(1e81.__noSuchMethod__.__lookupGetter__(\"constructor\"))) { default: break;  }");
tryItOut("L:if(0) {continue M; } else  if ( /x/g ) {continue M;__count__ getter: new Function; }");
tryItOut("<><x><y/></x></>\nlet (constructor =  \"\" ) { Math.pow }\n const __proto__;");
tryItOut("return;");
tryItOut("/*infloop*/while(true);");
tryItOut("with( /x/g )let , __noSuchMethod__ = prototype;");
tryItOut("while((<x/>) && 0){gc()gc() }");
tryItOut("let (__iterator__, constructor) { {const constructor;continue ; } }");
tryItOut("for(let y in [5,6,7,8]) this.zzz.zzz;");
tryItOut("let (__noSuchMethod__) { switch(<x><y/></x>) { default: break;  } }");
tryItOut("/*infloop*/for(let ({ get: [({ __iterator__: __iterator__ }), ], __parent__: ({ constructor: ({ __parent__: function::__iterator__, \nprop: prototype }) }) }) = __count__ = <x><y/></x>; __iterator__ =  /x/g ;; prop = (\n<y><z/></y>)) ({a1:1});");
tryItOut("{export *;constructor = <><x><y/></x></> }");
tryItOut("/*for..in*/L:for(const [__count__, prototype] = (0.1(prototype, true)) in <y><z/></y>) throw <x/>;");
tryItOut("{throw window; }");
tryItOut("\nnew Function\n");
tryItOut("/*for..in*/for(var __count__ in  \"\" .eval(window)) if(__iterator__.__defineSetter__(\"__count__\", [1,2,3,4].slice)) { } else  if ((#0=({__proto__: <y><z/></y>}))) ;");
tryItOut("__proto__ getter: [1,2,3,4].slice");
tryItOut("if(arguments--) {export __noSuchMethod__\nexport constructor; } else  if (({ __count__: ({ __noSuchMethod__: prototype, prototype: __proto__ }) }) = (yield __iterator__) >= #0=<y><z/></y>) {M:if(__noSuchMethod__.__lookupSetter__(\"__noSuchMethod__\").__defineSetter__(\"__count__\", #1#)) throw ({a1:1}); else  if ([15,16,17,18].sort(function(q) { return q; }, <x/>))  }");
tryItOut("/*for..in*/for(const prototype = __parent__(function::prop.throw(*::*)) in @foo) /*infloop*/for((0 .@x:: @foo); (__count__ %= *::*); ~-0) return;");
tryItOut("/*infloop*/L:for((<y><z/></y>.hasOwnProperty(\"prop\")); <x/>; true) {;gc() }");
tryItOut("/*for..in*/for(var <x/> in true((uneval(__iterator__ = <x><y/></x>)))['__noSuchMethod__'] in ((Math.pow)(3/0.@foo)))gc()");
tryItOut("if((({__proto__: (this.zzz.zzz), <><x><y/></x></>() getter: Math.sin }).isPrototypeOf([15,16,17,18].map(new Function, __iterator__)))) M:with({constructor: (new Boolean(( /* Comment */window), <><x><y/></x></\t>))((({prop, constructor: [,] })))})/*for..in*/for(var constructor in ((((0/0).__defineSetter__).call)(eval(\"constructor\", *)))){ }");
tryItOut("yield\n");
tryItOut("/*for..in*/M:for(constructor = false in new this.__defineSetter__(\"__count__\", function(y) { yield y; {}; yield y; })) {gc() }");
tryItOut("/*for..in*//* nogeckoex bug 349964 */ for  each(var __parent__ in (({__noSuchMethod__:  /x/ }))) /*infloop*/M:for(let prop; <x><y/></x>; @foo) ( \"\" );");
tryItOut("/*for..in*/for(var <x><y/></x>.__parent__ in __parent__) {}");
tryItOut("/*for..in*//* nogeckoex bug 349964 */ for  each(var prop in let (constructor, prop) true) L:if(\n '' ) gc() else throw <><x><y/></x></>;");
tryItOut("/*infloop*/for((window)[<><x><y/></x></>]; prop = undefined <= <y><z/></y>.watch(\"prototype\", (<y><z/></y>.__defineGetter__(\"constructor\", Math.sin))); <x>\f<y/></x>.yoyo(<x><y/></x>) ? constructor : (*)[<y><z/></y>] - (Math.pow)( \"\"  :: @foo /= .watch(\"(window)(({ __noSuchMethod__: __proto__ }))\", <x><y/></x> = __count__))) {/*for..in*//* nogeckoex bug 349964 */ for  each(let prototype in 1.3) L:while(((-1)) && 0)/*infloop*/while(\nfalse.__noSuchMethod__)with(__iterator__ = (function ([y]) { })())export prototype; }");
tryItOut("L:if(<x><y/></x>) {let function::prototype; } else {throw <x><y/></x>; }");
tryItOut("/*infloop*/L:for(let constructor; (p={}, (p.z = (<x/>\n))()); ((break )()) || new Math.sin()) {yield;export constructor; }");
tryItOut("while((0/0 ? <><x><y/></x></> : <x><y/></x> >>> ({__proto__: #1#}).yoyo(1e4.valueOf(\"number\") :: (<><x><y/></x></>)(@foo))) && 0){if(*::*) {gc() } else  if ( \"\" ) return *::*; else {; const __proto__; }\t }");
tryItOut("/*for..in*/L:for(__noSuchMethod__ in <><x><y/></x></>) /*for..in*/for(var [,].__noSuchMethod__ in  /x/ ) throw __parent__;");
tryItOut("{with({__proto__: <x/>.yoyo(this)})( '' ); }");
tryItOut("/*infloop*/for(var prop = (({a2:z2}) for each (__iterator__ in (function ([y]) { })())); <><x><y/></x></>.propertyIsEnumerable(\"__count__\"); this.__defineGetter__(\"prototype\", <x/>)) export __proto__;");
tryItOut("/*infloop*/\ffor([({ __noSuchMethod__: [__parent__] }), ({ constructor: __noSuchMethod__, constructor: ({ __proto__: ({ __count__: __noSuchMethod__, __count__: __noSuchMethod__ }) }) }), ({ __noSuchMethod__: __iterator__ }), ] = (prop.__parent__ setter= (null\t).__defineSetter__); [[]].__lookupSetter__(\"__proto__\"); (uneval([11,12,13,14].sort)) >> __iterator__ = __iterator__) yield <x/>;");
tryItOut("{return new [1,2,3,4].slice(this, <><x><y/></x></>);do {var __count__ = constructor setter: function(y) { yield y; __count__;; yield y; }, __noSuchMethod__;export __parent__; } while((<><x><y/></x></>) && 0); }");
tryItOut("/*for..in*/L:for(const __parent__ in ((new Function)(let (__proto__) <y><z/></y>.__count__))){if((yield (this.__defineGetter__(\"prototype\", Math.pow))).hasOwnProperty(\"constructor\")) /*for..in*/for(constructor.constructor in (((1 for (x in [])))((__parent__--)))){let constructor; } else {export *;gc() } }");
tryItOut("{function (__count__) { return __proto__ = null .@x:: [,,] |= * }  let __count__ = <x/>; }");
tryItOut("this.zzz.zzz;");
tryItOut("M:if(//h\n(prototype = window)) { if (((yield true))) {null;\fconstructor; }} else ");
tryItOut("return;");
tryItOut("while((<><x><y/></x></>['__noSuchMethod__']) && 0){return ({}); }");
tryItOut("/*for..in*//* nogeckoex bug 349964 */ for  each(let function::__noSuchMethod__ in eval(\"<x><y/></x>\", this).@*.watch(\"constructor\", eval)) {with({__count__: __count__}){throw __parent__; } }");
tryItOut("return;");
tryItOut("/*for..in*/for(__count__ in (((__proto__[<x><y/></x>]).watch)(prototype.__iterator__)))var __parent__ = ({})\n");
tryItOut("with({__iterator__: function () /x/g (({__count__:  /x/ }), 3) /= prop = (this.yoyo(/*)).@*}){gc() }");
tryItOut("if([z1]) { } else 'haha'.split");
tryItOut("if((((__parent__ = <x/>) @ __proto__ = yield __iterator__.valueOf(\"number\"))())) L:if((RangeError(set.__proto__ = #2=@foo))) {L: {(1 for (x in []))gc() }/*infloop*/L:for(var prototype = false; <x><y/></x>; this) undefined; } else  if (window.isPrototypeOf( /x/g )) export prop;");
tryItOut("L:if(*::*) {{}return function(id) { return id }; } else  if (\n[z1,,]) {(C); }");
tryItOut("for(let y in [5,6,7,8]) return;");
tryItOut("/*for..in*/for(let __noSuchMethod__ in (((yield (__noSuchMethod__.__parent__)))(new (*)().__iterator__)))M:while((__parent__ = <><x><y/></x></>) && 0){throw prototype;export *; }");
tryItOut("L: <><x><y/></x></>;");
tryItOut("let (({ function::constructor: ({ __parent__: prototype, prop: prototype }) }) = (0 for (__parent__ in ))) { yield; }");
tryItOut("/*infloop*/for(this ?  ''  : __parent__.prototype = ; (void window); <x><y/></x>.__proto__ = <y><z/></y>) if(__noSuchMethod__ = prop) while((@foo) && 0){\fMath.sin }");
tryItOut("let (prototype = __count__ = __proto__ = null, get = <x/> /=  \"\" ) { ( /x/g ); }");
tryItOut("/*infloop*/M:for(var prototype; <><employee id=\"1\"><name>Joe</name><age>20</age></employee></>; (<><x><y/></x></> ? <><x><y/></x></> : null) - ((uneval(({})\n)))) { /x/g ; }");
tryItOut("for(let y in [5,6,7,8]) ;");
tryItOut("with(<y><z/></y>){; }");
tryItOut("M:if(-3/0 ? undefined : <x><y/></x>) <ccc:ddd></ccc:ddd> else  if ((3/0 ? * : <><x><y/></x></>)) {*::*; }");
tryItOut("{const __parent__ = prototype, constructor = false; }");
tryItOut("try { for(let y in [5,6,7,8]) with({}) { export __proto__; }  } catch(__iterator__ if (function(){yield ;})()) { \treturn ((p={}, (p.z = <x><y/></x>)())); } catch(__iterator__) { (<><x><y/></x></>); } ");
tryItOut("throw 4.;Math.sin");
tryItOut("/*infloop*/while(this.__defineGetter__(\"__count__\", ({}).hasOwnProperty));");
tryItOut("export *;\nreturn;\n");
tryItOut("/*infloop*/while((__count__) = <><x><y/></x></>.eval(*))return;");
tryItOut("/*for..in*//* nogeckoex bug 349964 */M: for  each(var constructor in window ? 1e+81.propertyIsEnumerable(\"__iterator__\") : <x/>.prop = \t{}) return;");
tryItOut("throw prototype;");
tryItOut("let (__iterator__ = @foo) { return; }");
tryItOut("yield;\n)\n");
tryItOut("do return undefined; while(('fafafa'.replace(/a/g, function  __proto__ (__noSuchMethod__) { return <y><z/></y> } )) && 0);");
tryItOut("if(<><x><y/></x></>) { if (__count__) {} else export prop;}");
tryItOut("/*infloop*/");
tryItOut("\n");
tryItOut("throw __iterator__;");
tryItOut("/*infloop*/for(var __noSuchMethod__; (({ get (<xxx {__proto__}={(<x/>)()} />.(Math.pow))(__noSuchMethod__, prop) { return ({}) += ((window).watch) }  })); [({  /x/g , [[1]]: __parent__ }), , , [__iterator__]] = (null for (function::__parent__ in @foo))) {this;const __proto__, __parent__; }");
tryItOut("if((function::__count__.function::prototype = (p={}, (p.z = <x/>)()))) { if (1e-81 ?  ''  : [,]\n) {export __parent__;window; } else export *;}");
tryItOut("if() {return [[1]];export *; } else  if (({prototype: <><x><y/></x></>, prototype: false })) <x><y/></x>;");
tryItOut("/*for..in*/for([__count__, prototype] = <{prototype}><ccc:ddd><x><y/></x><ccc:ddd></ccc:ddd></ccc:ddd></{prototype}> in 1e81) <x><y/></x>");
tryItOut("if((__proto__.prop = (<><x><y/></x></>.__proto__ = null))) {yield;return __parent__; }");
tryItOut("(yield 'fafafa'.replace(/a/g, (<x/>).watch));\n(.2);\n(function (__count__, prototype) { yield window } ).call\n\n");
tryItOut("<><x><y/></x></>;");
tryItOut("__iterator__yield  '' ;");
tryItOut("");
tryItOut("(constructor);");
tryItOut("return __iterator__ ? this : <><x><y/></x></>;");
tryItOut("let(constructor = this) ((function(){yield;})());");
tryItOut("throw __iterator__;");
tryItOut("\n { return <><x><y/></x></> } \n");
tryItOut("/*infloop*/for(Object((new ((Function).call)()), __noSuchMethod__)--; constructor = #1#; prop = this) {/*infloop*/M:do yield true; while(); }");
tryItOut("/*for..in*/for(const [prototype, __iterator__] = prop in false.__lookupGetter__(\"__count__\")) /*infloop*/L:for(const __count__; *.yoyo(true); (new <x><y/></x>(null, <><x><y/></x></>))) {yield *::*; }\n/*infloop*/do let getter = 0x99, prototype; while(__iterator__.__noSuchMethod__);");
tryItOut(" set __proto__() { return (<><x><y/></x></>.throw(null)) } ");
tryItOut("/*for..in*//* nogeckoex bug 349964 */L: for  each(const __parent__ in (({ get function::constructor prop () { return undefined; }  })).(( /* Comment */function ([y]) { })[(*::* >>> <><x><y/>\t</x></>)]).__lookupGetter__(\"__proto__\")) {throw prop;/*for..in*/for(let [__noSuchMethod__, constructor] = ((null)[window]) in <><x><y/></x></>\n) {var __count__ = <><x><y/></x></>, function::prototype = __count__;<x/>; } }");
tryItOut("return;");
tryItOut("/*infloop*/do return; while((p={}, (p.z = this)()).prop);");
tryItOut("if(undefined.__defineSetter__(\"__noSuchMethod__\", (3/0).__defineSetter__)) { if ((new Object(try { with({}) { __count__ = <x><y/></x>; }  } catch(__iterator__ if * + [15,16,17,18].map(Math.sin, [1,,])) { try { {} } catch(__count__ if (function(){break ;})()) { return __noSuchMethod__; } catch(prototype) { continue L; } finally { export *; }  } catch(__iterator__ if <><x><y/></x></>.@foo) { return; } finally { let(prototype, let = 3/0) { yield; } ).let (prototype, <y><z/></y>, prototype) <x><y/></x> += __count__.__proto__)) {/*infloop*/for((undefined.isPrototypeOf(undefined)); (__parent__ && <x/>); ()) {throw __count__; } } else {(<><x><y/></x></>);/*for..in*//* nogeckoex bug 349964 */ for  each(var prototype in *) {let __count__, prop; ''  } }}\t");
tryItOut("L:if(constructor.(@foo)) { if ((<x><y/></x>\n)) throw function ([y]) { }; else throw  \"\" \f;}");
tryItOut("/*infloop*/L:do ; while(<x><y/></x>.hasOwnProperty(\"prototype\") && let (__parent__ = window) <x><y/></x>);");
tryItOut("M:if( /x/g )  else const __count__ = this, __noSuchMethod__ = 1.3;");
tryItOut("do {L:with(prototype)gc()gc() } while((<><bbb xmlns:ccc=\"this.zzz.zzz\"><ccc:eee></ccc:eee></bbb></>) && 0);");
tryItOut("/*for..in*/for(const \x7f in ((function (__count__) { export *;let constructor; } )(prototype = constructor.__parent__ = __iterator__))){throw <y><z/></y>;(<x><y/></x>); }\nexport __count__;\n");
tryItOut("if((<><x><y/></x></>).call([,,], <y><z/></y>, <><x><y/></x></>) ? *::* *= [,] : set in (this for (__noSuchMethod__ in *::*))) /*for..in*/for(let __parent__ in  /x/ ) yield; else (-0);prototype = true, __count__ = <x/>;");
tryItOut("M:if(<x/>) {{} } else {prototype }");
tryItOut("yield\nexport *;\n");
tryItOut("if([1]) { if (false) yield *::*; else gc()}");
tryItOut("return;");
tryItOut("with({}) { __parent__ = prototype; } ");
tryItOut("var prop, prototype;\n__count__\n");
tryItOut("{do {yield; } while((new <x><y/></x>) && 0);; }");
tryItOut("/*infloop*/do {with({__proto__: (<><x><y/></x></>.*)}){yield;continue L; } } while(({ __parent__: __count__, function::__proto__: ({ prop: __parent__, constructor: prop }) }) = false);");
tryItOut("if( /x/  >>= __proto__) { if ((prop = @foo)) (<>\n<x><y/></x></>); else ;}");
tryItOut("switch(this.zzz.zzz) { default: export __count__;break; break;  }");
tryItOut("{}");
tryItOut("if( /x/g ) { if (<x><y/></x>)  const  else {throw undefined;return; }}");
tryItOut("{return window;/*infloop*/while(<><x><y/></x></>) }");
tryItOut("return __parent__ = <xxx {__parent__}={<><x><y/></x></>} />;");
tryItOut("L: {do throw  /x/g ; while(('fafafa'.replace(/a/g, 'haha'.split)) && 0); }");
tryItOut("/*infloop*/for(var prop; ; (__count__.__noSuchMethod__ getter= ({}).__lookupGetter__)) new Function");
tryItOut("/*for..in*//* nogeckoex bug 349964 */ for  each(const <y><z/></y>['__iterator__'] in ) {/*infloop*/for(const __iterator__ = this; undefined; this) ({ prop: __iterator__ })return; }\n/*infloop*/L:do {gc(){prop = window; } } while((prop.__count__));");
tryItOut("{M:do {<y><z/></y>return <y><z/></y>; } while((false) && 0);/*infloop*/for(false; <y><z/></y>; __proto__) var __noSuchMethod__; }");
tryItOut("/*infloop*/for(({ __count__: __proto__, __noSuchMethod__: __proto__ }) = <><x><y/></x></>.__iterator__; 0.1;  \"\"  >> window) {gc()export *; }");
tryItOut("/*infloop*/for((__parent__.__parent__ = __proto__ =  \"\"  << ({a1:1}).hasOwnProperty(\"prototype\")) /= 1.2e3; (eval(\"0/0\", <x><y/></x>) += (prop+=<><x><y/></x></> >>>=[,,]).yoyo((<><x><y/></x></> + <y><z/></y> ||  \"\" ))); (<x/> >>= *::*).throw([prop])) throw *::*;");
tryItOut("if(#1#) { if ([[1]]) {__noSuchMethod__ = <><x><y/></x></>, __parent__; }} else {[1,2,3,4].mapexport __proto__; }");
tryItOut("while((prop.watch(\"__iterator__\", <><x><y/></x></>)) && 0){}");
tryItOut("M:if(<x><y/></x>");
tryItOut("/*for..in*/for(const __noSuchMethod__ = @foo in (function ([y]) { })()) {{} }");
tryItOut("if((RangeError(({})))) return  \"\" ; const __noSuchMethod__;");
tryItOut("{yield <x><y/></x>; ''  }");
tryItOut("if(([1,2,3,4].slice)() + __parent__) var __count__ = prototype; else  if ((uneval((gc)))) gc else { }");
tryItOut("L:with(({}).__lookupGetter__){{} }");
tryItOut("/*infloop*/for([15,16,17,18].filter((new Function(\"continue L;\")),  ''    == #1=[#1#]); yield <><x><y/></x></>; <y><z/></y>.__lookupSetter__(\"__proto__\")) {{__parent__ = false;let prop, prototype = *; } }");
tryItOut("if(  Function()) { if ({} != this) {}");
tryItOut("L: {function::constructor = <x><y/></x>, prototype; }");
tryItOut("gc()");
tryItOut("L:if((<x><y/>\t</x>.__lookupGetter__(\"prototype\"))) {(4.).call/*infloop*/for(<y><z/></y>; <x><y/></x>; ({a1:1})\n) __count__; } else with(prop)return;");
