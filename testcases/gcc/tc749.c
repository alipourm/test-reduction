/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --no-bitfields --checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --pre-incr-operator --no-pre-decr-operator --post-incr-operator --post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --no-math64 --inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --no-volatiles --no-volatile-pointers --const-pointers -o /project/alipour/c-testcases/swarm/tc749.c
 * Seed:      7997876
 */

#include <float.h>
#include <math.h>
#include "csmith.h"


static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   uint32_t  f0;
   uint32_t  f1;
   uint32_t  f2;
};

/* --- GLOBAL VARIABLES --- */
static struct S0 g_7 = {18446744073709551615UL,1UL,18446744073709551606UL};
static struct S0 *g_6 = &g_7;
static int32_t g_55 = 0x8D270C17L;
static int32_t **g_61 = (void*)0;
static struct S0 g_74 = {0x4ED1E225L,0UL,0x2C1E9780L};
static int32_t **g_102 = (void*)0;
static float g_106 = (-0x1.Fp-1);
static int32_t *g_135 = &g_55;
static struct S0 **g_145 = &g_6;
static struct S0 ***g_144 = &g_145;
static int32_t g_178 = (-1L);
static int32_t ***g_259 = &g_102;
static int32_t ****g_258 = &g_259;


/* --- FORWARD DECLARATIONS --- */
static const uint32_t  func_1(void);
inline static struct S0 * func_2(float  p_3);
static uint32_t  func_10(uint16_t  p_11, int16_t  p_12, struct S0 * p_13);
inline static struct S0 * const * func_16(float  p_17, int32_t  p_18, uint32_t  p_19, int32_t  p_20, int16_t  p_21);
inline static struct S0 * func_27(int16_t  p_28);
inline static uint16_t  func_31(float  p_32, struct S0 * p_33, float  p_34, struct S0 ** p_35, struct S0 ** p_36);
static struct S0 * func_37(uint32_t  p_38, struct S0 ** p_39);
static struct S0 * func_41(uint32_t  p_42, uint32_t  p_43, struct S0 ** p_44);
inline static uint16_t  func_47(int16_t  p_48);
inline static struct S0  func_57(int32_t  p_58, int32_t * p_59);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_6 g_7.f1 g_55 g_135 g_145 g_74.f2 g_7.f2 g_178 g_7 g_144 g_74.f1 g_258 g_74.f0 g_106 g_259 g_102
 * writes: g_7.f1 g_135 g_106 g_7.f2 g_55 g_7.f0 g_178 g_7 g_6 g_258
 */
static const uint32_t  func_1(void)
{ /* block id: 0 */
    uint16_t l_4 = 3UL;
    int32_t *****l_260 = &g_258;
    uint16_t l_286 = 65527UL;
    (**g_144) = func_2(l_4);
    /* statement id: 153 */
    assert (g_6 == 0 || g_6 == &g_7);
    (*l_260) = g_258;
    for (g_55 = 0; (g_55 < (-4)); g_55 = safe_sub_func_uint16_t_u_u(g_55, 1))
    { /* block id: 157 */
        uint32_t l_273 = 4294967289UL;
        float l_274 = 0x6.D6D82Ep+48;
        int32_t **l_281 = &g_135;
        float *l_287 = (void*)0;
        float *l_288 = &g_106;
        g_106 = (0xB.2AD1B8p+20 > (0x8.86B609p-67 < ((safe_sub_func_float_f_f(((safe_add_func_float_f_f(0x5.0051D5p+13, (((0x8.0p+1 != ((((safe_add_func_float_f_f((!(safe_sub_func_float_f_f((!g_7.f0), l_273))), 0x2.F2E3D4p-27)) <= l_273) > (((((l_273 == 0xC.9F27ABp-6) >= l_274) != g_178) >= l_273) < g_7.f2)) > g_7.f1)) >= 0x0.9p-1) >= g_74.f0))) >= g_74.f0), l_273)) >= 0xC.B2EAF8p-45)));
        g_106 = (safe_add_func_float_f_f((((l_273 >= (g_106 < ((safe_add_func_float_f_f((safe_sub_func_float_f_f(l_273, l_4)), ((l_281 != (***l_260)) <= ((safe_add_func_float_f_f(g_178, g_74.f2)) <= ((l_4 >= (**l_281)) < (**l_281)))))) <= g_74.f2))) == g_74.f0) != 0x0.Ap-1), g_7.f2));
        (*l_281) = (*l_281);
        (*l_288) = ((**l_281) < (safe_sub_func_float_f_f(g_7.f1, ((**l_281) <= ((g_7.f1 < l_286) <= ((void*)0 != &g_259))))));
    }
    return g_178;
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_7.f1 g_55 g_135 g_145 g_74.f2 g_7.f2 g_178 g_7 g_144 g_74.f1
 * writes: g_7.f1 g_135 g_106 g_7.f2 g_55 g_7.f0 g_178 g_7 g_6
 */
inline static struct S0 * func_2(float  p_3)
{ /* block id: 1 */
    int32_t l_5 = (-1L);
    struct S0 *l_24 = &g_7;
    int32_t * const l_163 = &g_55;
    const int32_t *l_210 = &g_55;
    const int32_t **l_209 = &l_210;
    const int32_t ***l_208 = &l_209;
    const int32_t ****l_207 = &l_208;
    if (l_5)
    { /* block id: 2 */
        return g_6;
        /* statement id: 3 */
        //assert (func_2_rv == &g_7);
    }
    else
    { /* block id: 4 */
        struct S0 *l_15 = &g_7;
        int32_t l_23 = (-5L);
        int32_t **l_164 = &g_135;
        const int32_t *l_189 = &l_23;
        const int32_t **l_188 = &l_189;
        const int32_t ***l_187 = &l_188;
        const int32_t ****l_186 = &l_187;
        float l_241 = 0x2.4p+1;
        for (g_7.f1 = 0; (g_7.f1 != 28); ++g_7.f1)
        { /* block id: 7 */
            int32_t l_14 = 3L;
            struct S0 *l_160 = &g_74;
        }
        (*l_164) = l_163;
        if ((((safe_add_func_uint32_t_u_u((((*l_163) | (((**l_164) <= 0x6903EB46L) || ((*l_163) >= 1L))) || (*l_163)), (((0x9B9E4C78L != (l_15 == (*g_145))) & (*l_163)) && 0xBDF4B4D0L))) <= (-1L)) && 0x8A4D6DA3L))
        { /* block id: 99 */
            float *l_167 = (void*)0;
            float *l_168 = &g_106;
            int32_t l_173 = (-1L);
            int32_t *l_191 = &g_55;
            int32_t ***l_212 = (void*)0;
            int32_t ****l_211 = &l_212;
            const float l_225 = (-0x1.3p-1);
            const int32_t *****l_230 = (void*)0;
            (*l_168) = g_74.f2;
            for (g_7.f2 = 0; (g_7.f2 >= 11); g_7.f2 = safe_add_func_uint16_t_u_u(g_7.f2, 1))
            { /* block id: 103 */
                const uint32_t l_179 = 18446744073709551615UL;
                int32_t *l_180 = &g_55;
                struct S0 l_181 = {1UL,0x4882EDD9L,18446744073709551609UL};
                l_181 = func_57(((((((void*)0 != l_15) > (((*l_163) | (safe_rshift_func_uint16_t_u_u((*l_163), 5))) && (l_173 && (((0x91F8L || (*l_163)) != (((safe_rshift_func_uint16_t_u_u(((4294967289UL > ((safe_mod_func_int16_t_s_s((((**l_164) == g_178) == 0x52836DD0L), g_74.f2)) <= l_179)) ^ l_173), 12)) >= g_178) ^ g_178)) != 7L)))) | (**l_164)) && 8L) == g_74.f2), l_180);
                if (l_173)
                { /* block id: 105 */
                    (*l_164) = (*l_164);
                    for (l_181.f0 = 0; (l_181.f0 != 3); ++l_181.f0)
                    { /* block id: 109 */
                        (*l_180) = 0L;
                    }
                    return (*g_145);
                    /* statement id: 112 */
                    //assert (func_2_rv == &g_7);
                }
                else
                { /* block id: 113 */
                    const int32_t *****l_190 = &l_186;
                    for (g_7.f0 = 0; (g_7.f0 > 12); ++g_7.f0)
                    { /* block id: 116 */
                        l_173 = (*l_180);
                        (*l_168) = p_3;
                        (*l_168) = p_3;
                        if (l_173)
                            continue;
                    }
                    if ((**l_164))
                        continue;
                    (*l_190) = l_186;
                }
            }
            (*l_188) = l_191;
            /* statement id: 126 */
            assert (l_189 == &g_55);
            for (g_178 = 0; (g_178 <= (-16)); g_178--)
            { /* block id: 129 */
                struct S0 l_194 = {18446744073709551615UL,0x190E703EL,0x88BD6EBFL};
                const int32_t *l_195 = (void*)0;
                int32_t *** const ** const l_255 = (void*)0;
                (**g_145) = l_194;
                (***l_186) = l_195;
                /* statement id: 131 */
                assert (l_189 == 0);
                (*g_135) = (safe_rshift_func_int16_t_s_u(((safe_unary_minus_func_uint16_t_u((*l_191))) | ((safe_sub_func_int16_t_s_s((safe_mod_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u((safe_add_func_uint32_t_u_u((l_207 == l_211), (safe_rshift_func_uint16_t_u_s((**l_164), 1)))), (safe_sub_func_uint32_t_u_u(((((*g_135) && (safe_mod_func_uint32_t_u_u((safe_sub_func_uint32_t_u_u(((safe_add_func_uint16_t_u_u((*l_191), ((g_7.f2 && (safe_lshift_func_uint16_t_u_u(((void*)0 == (*g_144)), g_74.f1))) < 0x8E0FL))) > 0xC18CAC26L), (***l_208))), (**l_164)))) & (*g_135)) < 65527UL), (*l_191))))), g_55)), g_55)) ^ g_74.f2)), 10));
                if (((0x8C781C0EL != g_55) & (safe_rshift_func_int16_t_s_s(((0xBA4ED1C8L >= (safe_mod_func_uint16_t_u_u((((((((*l_163) >= ((void*)0 != l_230)) != (safe_add_func_int32_t_s_s((safe_sub_func_uint16_t_u_u((safe_sub_func_int32_t_s_s((safe_lshift_func_int16_t_s_s((safe_rshift_func_uint16_t_u_s(0xBD41L, ((*l_210) & 0x7B37L))), 7)), 0x1A84ED83L)), (*l_163))), g_74.f2))) | (*g_135)) < 0x5E94D96BL) == 0x38BFL) != (*l_191)), g_7.f0))) <= 0xB400L), 9))))
                { /* block id: 133 */
                    struct S0 *l_242 = (void*)0;
                    return l_242;
                    /* statement id: 134 */
                    //assert (func_2_rv == 0);
                }
                else
                { /* block id: 135 */
                    int16_t l_254 = (-1L);
                    if ((((safe_sub_func_int32_t_s_s((safe_add_func_uint32_t_u_u((~(((*g_135) & ((safe_rshift_func_int16_t_s_u(((safe_sub_func_int32_t_s_s(1L, 1UL)) | ((safe_lshift_func_int16_t_s_s((***l_208), 8)) & 0xFA0CL)), 8)) == l_254)) || (g_74.f1 >= ((&l_186 == l_255) == (**l_164))))), 0x8C1E0F0DL)), (**l_164))) >= g_74.f2) && (**l_164)))
                    { /* block id: 136 */
                        int32_t *l_256 = &l_23;
                        (***g_144) = func_57(g_7.f2, l_256);
                    }
                    else
                    { /* block id: 138 */
                        (*g_145) = (**g_144);
                        if (l_254)
                            break;
                        (*l_188) = (*l_209);
                        /* statement id: 141 */
                        assert (l_189 == &g_55);
                        (**l_208) = (**l_208);
                    }
                    /* facts after branching */
                    assert (l_189 == &g_55 || l_189 == 0);
                    if ((**l_164))
                        break;
                }
                /* facts after branching */
                assert (l_189 == &g_55 || l_189 == 0);
            }
            /* facts after for loop */
            assert (l_189 == &g_55 || l_189 == 0);
        }
        else
        { /* block id: 147 */
            int32_t *l_257 = &g_55;
            (*l_164) = l_257;
        }
        /* facts after branching */
        assert (l_189 == &l_23 || l_189 == &g_55 || l_189 == 0);
    }
    (**l_208) = (***l_207);
    return l_24;
    /* statement id: 152 */
    //assert (func_2_rv == &g_7);
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static uint32_t  func_10(uint16_t  p_11, int16_t  p_12, struct S0 * p_13)
{ /* block id: 8 */
    return p_11;
}


/* ------------------------------------------ */
/* 
 * reads : g_145
 * writes: g_106 g_6
 */
inline static struct S0 * const * func_16(float  p_17, int32_t  p_18, uint32_t  p_19, int32_t  p_20, int16_t  p_21)
{ /* block id: 72 */
    struct S0 *l_149 = &g_7;
    float *l_150 = &g_106;
    (*l_150) = ((void*)0 != l_149);
    (*g_145) = (void*)0;
    /* statement id: 74 */
    assert (g_6 == 0);
    return &g_6;
    /* statement id: 75 */
    //assert (func_16_rv == &g_6);
}


/* ------------------------------------------ */
/* 
 * reads : g_7.f1 g_7.f2 g_61 g_55 g_6 g_7 g_74.f0 g_74.f1 g_74.f2 g_102 g_135 g_74
 * writes: g_55 g_74 g_106 g_135 g_144
 */
inline static struct S0 * func_27(int16_t  p_28)
{ /* block id: 11 */
    uint16_t l_40 = 0x132DL;
    struct S0 **l_51 = &g_6;
    struct S0 **l_93 = (void*)0;
    struct S0 **l_107 = &g_6;
    int32_t *l_147 = &g_55;
    (*l_147) = (safe_rshift_func_uint16_t_u_s(func_31(g_7.f1, func_37(func_10(l_40, p_28, func_41(l_40, (func_10((safe_sub_func_int16_t_s_s((g_7.f2 != p_28), (func_47((((((safe_lshift_func_int16_t_s_s((l_51 != l_51), (safe_rshift_func_uint16_t_u_u(l_40, 1)))) >= 0x3F079038L) <= 0x2AFCL) && p_28) ^ 5UL)) ^ l_40))), p_28, (*l_51)) > 0xF91B2076L), l_93)), l_107), p_28, l_93, l_51), 14));
    /* statement id: 69 */
    //assert (g_135 == dangling || g_135 == &g_55);
    //assert (g_144 == &g_145 || g_144 == dangling);
    l_147 = l_147;
    return (*l_51);
    /* statement id: 71 */
    //assert (func_27_rv == &g_7);
}


/* ------------------------------------------ */
/* 
 * reads : g_6 g_55 g_74.f0 g_7.f0 g_7 g_74.f1 g_135 g_74
 * writes: g_55 g_74.f0 g_135 g_144 g_74
 */
inline static uint16_t  func_31(float  p_32, struct S0 * p_33, float  p_34, struct S0 ** p_35, struct S0 ** p_36)
{ /* block id: 41 */
    float *l_119 = &g_106;
    uint32_t l_126 = 0x9EB03130L;
    struct S0 *l_127 = &g_74;
    int32_t l_134 = 1L;
    uint32_t l_138 = 0UL;
    int32_t *l_146 = (void*)0;
    if ((safe_rshift_func_uint16_t_u_s((((void*)0 == l_119) || (0UL && ((((safe_add_func_int32_t_s_s((safe_sub_func_uint32_t_u_u((safe_lshift_func_int16_t_s_u((l_126 & (l_126 >= ((0xB1D6L >= ((*p_36) == l_127)) < 0x5F7132E5L))), l_126)), l_126)), 0xC3B02FF5L)) != l_126) || l_126) & l_126))), l_126)))
    { /* block id: 42 */
        int32_t *l_128 = &g_55;
        (*l_128) = (l_119 != l_128);
        return (*l_128);
    }
    else
    { /* block id: 45 */
        int32_t *l_133 = &g_55;
        for (g_74.f0 = 0; (g_74.f0 >= 41); ++g_74.f0)
        { /* block id: 48 */
            float l_139 = 0x3.9p+1;
            int32_t l_140 = (-7L);
            int32_t **l_143 = &g_135;
            if ((safe_rshift_func_int16_t_s_s((1UL <= (((void*)0 != l_133) & (((&g_6 == &g_6) >= 1UL) && ((*l_133) == l_126)))), 10)))
            { /* block id: 49 */
                l_134 = 2L;
            }
            else
            { /* block id: 51 */
                g_135 = &l_134;
                /* statement id: 52 */
                assert (g_135 == &l_134);
            }
            /* facts after branching */
            assert (g_135 == &l_134 || g_135 == &g_55);
            if (((((g_7.f0 < (*l_133)) & (65526UL < 0x14A3L)) && (safe_add_func_int32_t_s_s((l_138 == ((&l_127 == &p_33) != 0x08BCL)), l_140))) != 0xF01BL))
            { /* block id: 54 */
                struct S0 l_141 = {0x0C71652FL,0x558AF5EEL,0UL};
                l_141 = (*p_33);
            }
            else
            { /* block id: 56 */
                struct S0 l_142 = {1UL,18446744073709551615UL,18446744073709551610UL};
                l_142 = func_57(l_138, l_133);
                return g_74.f0;
                /* statement id: 58 */
                //assert (g_135 == dangling || g_135 == &g_55);
            }
            (*g_135) = (((void*)0 == &p_33) < (g_74.f1 ^ g_7.f0));
            (*l_143) = l_133;
            /* statement id: 61 */
            assert (g_135 == &g_55);
        }
        g_144 = &p_36;
        /* statement id: 63 */
        assert (g_144 == &p_36);
    }
    /* facts after branching */
    assert (g_144 == &p_36);
    (*l_127) = (*l_127);
    (*l_127) = (*l_127);
    l_146 = &l_134;
    /* statement id: 67 */
    assert (l_146 == &l_134);
    return g_55;
    /* statement id: 68 */
    //assert (g_144 == dangling);
}


/* ------------------------------------------ */
/* 
 * reads : g_55 g_6
 * writes: g_55
 */
static struct S0 * func_37(uint32_t  p_38, struct S0 ** p_39)
{ /* block id: 35 */
    int32_t *l_108 = &g_55;
    int32_t **l_109 = &l_108;
    int32_t l_112 = 0x9F52E165L;
    int32_t ****l_113 = (void*)0;
    int32_t ****l_114 = (void*)0;
    int32_t ***l_116 = &l_109;
    int32_t ****l_115 = &l_116;
    (*l_109) = l_108;
    (*l_108) = (safe_sub_func_uint16_t_u_u(((l_112 != (*l_108)) <= p_38), 0x568EL));
    (*l_109) = (*l_109);
    (*l_115) = (void*)0;
    /* statement id: 39 */
    assert (l_116 == 0);
    return (*p_39);
    /* statement id: 40 */
    //assert (func_37_rv == &g_7);
}


/* ------------------------------------------ */
/* 
 * reads : g_102 g_74.f2 g_74.f0 g_7.f2
 * writes: g_106
 */
static struct S0 * func_41(uint32_t  p_42, uint32_t  p_43, struct S0 ** p_44)
{ /* block id: 32 */
    int32_t *l_101 = (void*)0;
    const struct S0 *l_104 = &g_74;
    float *l_105 = &g_106;
    (*l_105) = (-(((safe_add_func_float_f_f((((p_42 > ((safe_add_func_float_f_f(((safe_sub_func_float_f_f((l_101 != (void*)0), p_43)) == (g_102 != &l_101)), (-((g_74.f2 > p_43) == (l_104 != l_104))))) >= p_43)) <= g_74.f0) < 0x4.425F0Fp+66), 0x9.3ADB54p-83)) >= g_7.f2) == p_43));
    return &g_7;
    /* statement id: 34 */
    //assert (func_41_rv == &g_7);
}


/* ------------------------------------------ */
/* 
 * reads : g_61 g_7.f1 g_7.f2 g_55 g_6 g_7 g_74.f0 g_74.f1 g_74.f2
 * writes: g_55 g_74
 */
inline static uint16_t  func_47(int16_t  p_48)
{ /* block id: 12 */
    int32_t *l_54 = &g_55;
    int32_t **l_56 = (void*)0;
    struct S0 *l_60 = &g_7;
    struct S0 *l_72 = (void*)0;
    struct S0 *l_73 = &g_74;
    int32_t l_88 = 1L;
    int32_t l_92 = 0x5B3E5B60L;
    l_54 = l_54;
    (*l_73) = func_57(((l_60 != l_60) ^ ((&l_54 != g_61) > ((safe_add_func_uint32_t_u_u(((safe_unary_minus_func_uint32_t_u(p_48)) && g_7.f1), ((safe_mod_func_uint32_t_u_u((((p_48 >= (0x1F3EL >= ((7L | p_48) & 0xCBABA27FL))) || 0x425FL) <= 0xB09EDB9CL), 4294967295UL)) || g_7.f2))) ^ 0L))), l_54);
    for (g_74.f0 = 20; (g_74.f0 != 20); g_74.f0 = safe_add_func_uint16_t_u_u(g_74.f0, 6))
    { /* block id: 25 */
        uint32_t l_77 = 0xF656345DL;
        int32_t l_91 = 0x990E41E6L;
        l_77 = p_48;
        l_91 = ((((safe_unary_minus_func_uint32_t_u((7L <= g_74.f1))) && (((safe_lshift_func_uint16_t_u_u(((l_77 <= 0x2B88L) < ((safe_rshift_func_int16_t_s_s((safe_lshift_func_int16_t_s_s((g_74.f2 >= ((!p_48) < p_48)), (safe_add_func_int32_t_s_s(l_88, (safe_rshift_func_int16_t_s_u(((((void*)0 != &l_54) < 3L) == p_48), g_7.f1)))))), p_48)) & (-7L))), 3)) | p_48) || g_74.f1)) ^ g_7.f1) < l_77);
        l_91 = (g_74.f0 < ((p_48 != 0x8467E5F3L) > l_92));
        return g_74.f1;
    }
    return g_7.f2;
}


/* ------------------------------------------ */
/* 
 * reads : g_55 g_6 g_7
 * writes: g_55
 */
inline static struct S0  func_57(int32_t  p_58, int32_t * p_59)
{ /* block id: 14 */
    struct S0 l_70 = {0x7D735F31L,9UL,18446744073709551615UL};
    struct S0 *l_71 = &l_70;
    for (g_55 = 22; (g_55 < 4); g_55 = safe_sub_func_int32_t_s_s(g_55, 4))
    { /* block id: 17 */
        int32_t l_69 = 0xF075F97EL;
        if (l_69)
            break;
    }
    (*l_71) = l_70;
    return (*g_6);
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    crc32_gentab();
    func_1();
    transparent_crc(g_7.f0, "g_7.f0", print_hash_value);
    transparent_crc(g_7.f1, "g_7.f1", print_hash_value);
    transparent_crc(g_7.f2, "g_7.f2", print_hash_value);
    transparent_crc(g_55, "g_55", print_hash_value);
    transparent_crc(g_74.f0, "g_74.f0", print_hash_value);
    transparent_crc(g_74.f1, "g_74.f1", print_hash_value);
    transparent_crc(g_74.f2, "g_74.f2", print_hash_value);
    transparent_crc_bytes (&g_106, sizeof(g_106), "g_106", print_hash_value);
    transparent_crc(g_178, "g_178", print_hash_value);
    platform_main_end(crc32_context ^ 0xFFFFFFFFUL, print_hash_value);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 65
   depth: 1, occurrence: 5
XXX total union variables: 0

XXX max expression depth: 30
breakdown:
   depth: 1, occurrence: 108
   depth: 2, occurrence: 12
   depth: 3, occurrence: 2
   depth: 4, occurrence: 3
   depth: 7, occurrence: 1
   depth: 9, occurrence: 1
   depth: 10, occurrence: 1
   depth: 13, occurrence: 1
   depth: 15, occurrence: 1
   depth: 16, occurrence: 3
   depth: 18, occurrence: 1
   depth: 20, occurrence: 3
   depth: 22, occurrence: 1
   depth: 24, occurrence: 1
   depth: 30, occurrence: 1

XXX total number of pointers: 81

XXX times a variable address is taken: 71
XXX times a pointer is dereferenced on RHS: 60
breakdown:
   depth: 1, occurrence: 40
   depth: 2, occurrence: 16
   depth: 3, occurrence: 4
XXX times a pointer is dereferenced on LHS: 41
breakdown:
   depth: 1, occurrence: 35
   depth: 2, occurrence: 4
   depth: 3, occurrence: 2
XXX times a pointer is compared with null: 10
XXX times a pointer is compared with address of another variable: 7
XXX times a pointer is compared with another pointer: 7
XXX times a pointer is qualified to be dereferenced: 173

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 115
   level: 2, occurrence: 30
   level: 3, occurrence: 13
   level: 4, occurrence: 2
   level: 5, occurrence: 6
XXX number of pointers point to pointers: 39
XXX number of pointers point to scalars: 25
XXX number of pointers point to structs: 17
XXX percent of pointers has null in alias set: 28.4
XXX average alias set size: 1.19

XXX times a non-volatile is read: 345
XXX times a non-volatile is write: 117
XXX times a volatile is read: 0
XXX    times read thru a pointer: 0
XXX times a volatile is write: 0
XXX    times written thru a pointer: 0
XXX times a volatile is available for access: 0
XXX percentage of non-volatile access: 100

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 89
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 33
   depth: 1, occurrence: 17
   depth: 2, occurrence: 9
   depth: 3, occurrence: 11
   depth: 4, occurrence: 9
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 20.1
XXX percentage an existing variable is used: 79.9
********************* end of statistics **********************/

