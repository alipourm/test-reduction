/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --no-arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --no-post-incr-operator --no-post-decr-operator --no-unary-plus-operator --no-jumps --longlong --no-int8 --no-uint8 --float --math64 --inline-function --no-muls --safe-math --no-packed-struct --no-paranoid --pointers --structs --unions --volatiles --no-volatile-pointers --const-pointers -o /project/alipour/c-testcases/swarm/tc774.c
 * Seed:      3054217558
 */

#include <float.h>
#include <math.h>
#include "csmith.h"

volatile uint64_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   float  f0;
   volatile int64_t  f1;
   uint64_t  f2;
   uint32_t  f3;
};

struct S1 {
   uint32_t  f0;
};

/* --- GLOBAL VARIABLES --- */
static float g_33 = 0x8.93F6A0p-25;
static struct S1 g_42 = {18446744073709551615UL};
static struct S1 *g_41 = &g_42;
static int32_t g_47 = 0x7F28A996L;
static volatile int32_t g_52 = 0xABA4A2C6L;/* VOLATILE GLOBAL g_52 */
static volatile int32_t *g_51 = &g_52;
static volatile int32_t **g_50 = &g_51;
static volatile int32_t ***g_49 = &g_50;
static volatile float g_67 = 0xD.23E821p-81;/* VOLATILE GLOBAL g_67 */
static int32_t g_153 = (-1L);
static const struct S0 g_156 = {0xF.5E51F8p+10,1L,18446744073709551615UL,0x53E959B8L};/* VOLATILE GLOBAL g_156 */
static struct S0 g_213 = {0x0.9p-1,0x24A368C1170D4C16LL,0x46236CA140F996A6LL,0x810AE63EL};/* VOLATILE GLOBAL g_213 */
static int32_t *g_215 = &g_47;
static volatile float *g_227 = &g_67;
static volatile float **g_226 = &g_227;
static struct S0 g_246 = {0x1.4p-1,0x8190F3A04F61B098LL,0UL,4294967290UL};/* VOLATILE GLOBAL g_246 */
static struct S0 g_247 = {0x3.E51102p-96,0L,18446744073709551614UL,0xF62BBA29L};/* VOLATILE GLOBAL g_247 */
static int32_t g_259 = 0L;
static volatile struct S0 *g_301 = (void*)0;
static volatile struct S0 **g_300 = &g_301;
static volatile struct S0 g_312 = {0x4.Dp+1,2L,0xBBE3C6850E3D9A88LL,0UL};/* VOLATILE GLOBAL g_312 */
static volatile struct S0 g_313 = {0xD.498303p-57,0x86A746CB84E66C39LL,9UL,0x14A6CCC6L};/* VOLATILE GLOBAL g_313 */
static struct S0 g_320 = {0x0.8p-1,-1L,18446744073709551610UL,0x7AFACD92L};/* VOLATILE GLOBAL g_320 */
static struct S0 g_321 = {0x3.5A876Bp-8,0x8E82138A2B4C7A86LL,18446744073709551606UL,0UL};/* VOLATILE GLOBAL g_321 */
static struct S0 g_322 = {0x1.5p+1,0x1D896C24658D1362LL,0xE10B6CEE0769A12CLL,0xEF5C302EL};/* VOLATILE GLOBAL g_322 */
static volatile struct S1 g_346 = {0xAC6F9D89L};/* VOLATILE GLOBAL g_346 */
static volatile struct S1 *g_345 = &g_346;
static volatile struct S1 **g_344 = &g_345;
static volatile struct S1 ***g_343 = &g_344;
static volatile struct S1 ****g_342 = &g_343;
static volatile int32_t g_381 = (-1L);/* VOLATILE GLOBAL g_381 */
static volatile int32_t g_382 = 0x47B185C6L;/* VOLATILE GLOBAL g_382 */
static struct S0 g_390 = {0x3.A12725p-24,0x2575828B78B4E161LL,0x205DDFC62B8D9490LL,0xE8A5A11CL};/* VOLATILE GLOBAL g_390 */
static struct S0 g_391 = {0x0.1p+1,0xA2AF761C272038A2LL,0xE407AA3E77EADD43LL,0x1477426CL};/* VOLATILE GLOBAL g_391 */
static float *g_421 = &g_246.f0;
static float **g_420 = &g_421;
static float ***g_428 = &g_420;
static float ****g_427 = &g_428;
static const volatile struct S0 g_431 = {-0x7.Ap+1,0x26A0A948151461E7LL,1UL,0UL};/* VOLATILE GLOBAL g_431 */
static volatile struct S0 g_432 = {0x1.Bp-1,5L,8UL,0xEE8AF59BL};/* VOLATILE GLOBAL g_432 */
static struct S0 * const ***g_478 = (void*)0;
static struct S1 **g_489 = &g_41;
static volatile int32_t *g_497 = (void*)0;
static volatile struct S0 g_503 = {0x1.Dp-1,0xCFCA025045E58E42LL,0xE37431FF77F35D9CLL,0x1DAB4E5CL};/* VOLATILE GLOBAL g_503 */
static volatile struct S0 g_504 = {0x1.8336A1p-83,-5L,0UL,1UL};/* VOLATILE GLOBAL g_504 */
static struct S0 g_539 = {0x2.246391p-3,0xDD26A85871FE3574LL,0UL,0xDFB016FBL};/* VOLATILE GLOBAL g_539 */
static const struct S0 g_573 = {0xE.F99F8Ap+78,0L,3UL,0x377A45DEL};/* VOLATILE GLOBAL g_573 */
static volatile int64_t g_599 = 0x54F906E96323452DLL;/* VOLATILE GLOBAL g_599 */
static volatile int32_t ** const **g_647 = (void*)0;
static volatile int32_t ** const ***g_646 = &g_647;
static int64_t g_704 = (-2L);


/* --- FORWARD DECLARATIONS --- */
static const uint32_t  func_1(void);
inline static struct S0  func_2(float  p_3, int32_t  p_4, uint32_t  p_5);
static float  func_8(uint64_t  p_9, float  p_10, float  p_11, uint32_t  p_12, int32_t  p_13);
inline static uint32_t  func_14(int32_t  p_15);
static uint32_t  func_16(uint32_t  p_17);
static int64_t  func_18(uint32_t  p_19, int32_t  p_20, int64_t  p_21, struct S1  p_22, uint32_t  p_23);
inline static uint32_t  func_25(uint16_t  p_26, int64_t  p_27, struct S1  p_28, int32_t  p_29, uint32_t  p_30);
static int64_t  func_31(uint32_t  p_32);
inline static struct S1 * func_35(struct S1 * p_36, struct S1 * p_37, uint32_t  p_38, struct S1 * p_39, uint32_t  p_40);
static struct S1 * func_43(float  p_44);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_41 g_49 g_42.f0 g_50 g_51 g_52 g_47 g_42 g_33 g_67 g_321.f3 g_259 g_381 g_322.f3 g_153 g_382 g_215 g_320.f1 g_312.f3 g_213.f2 g_390 g_391.f3 g_226 g_227 g_156.f3 g_420 g_431 g_321.f2 g_247.f0 g_320.f3 g_343 g_344 g_345 g_247.f1 g_156.f2 g_312.f1 g_428 g_421 g_246.f0 g_478 g_300 g_301 g_213.f3 g_497 g_503 g_342 g_213.f1 g_246.f2 g_247.f2 g_539 g_504.f3 g_573 g_599 g_346.f0
 * writes: g_49 g_52 g_41 g_67 g_33 g_50 g_47 g_153 g_51 g_391 g_215 g_247.f0 g_213.f2 g_247.f3 g_427 g_432 g_390.f2 g_345 g_489 g_301 g_246.f0 g_504 g_320.f3 g_246 g_42.f0 g_346
 */
static const uint32_t  func_1(void)
{ /* block id: 0 */
    uint32_t l_24 = 0UL;
    uint32_t l_34 = 0xC013CEF3L;
    uint32_t l_73 = 0xE1A273DDL;
    struct S1 l_386 = {0xAF55B2A7L};
    struct S0 *l_540 = (void*)0;
    struct S0 *l_541 = (void*)0;
    struct S0 *l_542 = &g_246;
    int64_t l_557 = (-1L);
    int16_t l_559 = 0x15E6L;
    float ***l_578 = (void*)0;
    uint64_t l_598 = 0x857150289F0EA6DALL;
    int32_t *l_610 = &g_153;
    int32_t * const l_623 = &g_153;
    int32_t **l_697 = &l_610;
    int32_t *** const l_696 = &l_697;
    int32_t l_703 = 0x423C22EFL;
    struct S1 ***l_781 = &g_489;
    struct S1 ****l_780 = &l_781;
    struct S1 *****l_779 = &l_780;
    uint32_t l_798 = 0UL;
    (*l_542) = func_2((safe_add_func_float_f_f(0xD.A012E1p+92, func_8(((func_14(((func_16((func_18(l_24, ((func_25(((func_31(l_34) == (safe_sub_func_uint32_t_u_u((safe_rshift_func_uint16_t_u_s(l_34, (!0x5B7DFF937B1BDA2DLL))), ((*g_50) == (*g_50))))) ^ g_42.f0), l_73, g_42, g_47, g_47) || g_312.f3) & l_24), g_213.f2, l_386, l_34) <= l_73)) > 0xAC444CB2L) >= g_320.f3)) != l_386.f0) < g_321.f3), l_386.f0, l_24, g_246.f2, l_34))), g_247.f2, l_24);
    if (l_386.f0)
    { /* block id: 233 */
        struct S0 *** const l_556 = (void*)0;
        int32_t l_558 = (-9L);
        const struct S1 ****l_564 = (void*)0;
        if ((((0x072F342E47C06747LL == (safe_mod_func_uint16_t_u_u((safe_rshift_func_int16_t_s_s(1L, 12)), 3L))) ^ (safe_add_func_uint16_t_u_u(((safe_unary_minus_func_int32_t_s((*g_215))) != l_34), (((0x5E5FD3F0L ^ (g_504.f3 | ((safe_add_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u(((safe_lshift_func_uint16_t_u_s(g_47, 13)) > ((void*)0 != l_556)), g_246.f2)), l_557)) <= l_558))) || l_559) != g_153)))) ^ l_34))
        { /* block id: 234 */
            int32_t l_570 = 0L;
            (**g_226) = ((**g_420) >= ((((safe_add_func_float_f_f(l_558, (safe_sub_func_float_f_f((l_564 != (void*)0), (-0x6.1p+1))))) == (-0x1.3p-1)) > (safe_add_func_float_f_f((-0x4.4p-1), (-(safe_div_func_float_f_f((0x0.4p-1 < (&l_558 == (void*)0)), l_570)))))) == 0x2.B4556Fp-13));
            for (g_213.f2 = 0; (g_213.f2 >= 47); g_213.f2 = safe_add_func_uint64_t_u_u(g_213.f2, 9))
            { /* block id: 238 */
                const float l_574 = (-0x1.Ap+1);
                (*l_542) = g_573;
                return g_391.f3;
            }
        }
        else
        { /* block id: 242 */
            (*g_50) = (*g_50);
            (*g_215) = (!g_321.f2);
            (*g_215) = l_558;
        }
    }
    else
    { /* block id: 247 */
        int16_t l_579 = 0xCFF0L;
        int32_t * const l_609 = &g_47;
        int32_t ****l_613 = (void*)0;
        int32_t *****l_614 = (void*)0;
        int32_t *****l_615 = &l_613;
        if (((18446744073709551606UL > ((void*)0 != l_578)) & l_579))
        { /* block id: 248 */
            (*g_50) = (**g_49);
        }
        else
        { /* block id: 250 */
            int32_t *l_582 = &g_47;
            volatile struct S1 *****l_600 = (void*)0;
            (*g_227) = (safe_sub_func_float_f_f(((void*)0 == l_582), ((*g_421) == (((safe_div_func_float_f_f(((!((((-(((safe_div_func_float_f_f((safe_div_func_float_f_f((**g_420), (safe_add_func_float_f_f((safe_div_func_float_f_f(l_579, ((-((safe_add_func_float_f_f(0x6.196C29p+92, (*l_582))) == l_24)) > 0xB.A9AF58p+19))), (-0x1.0p+1))))), l_598)) != l_579) > 0x0.7p-1)) == (-0x1.7p-1)) < g_599) > 0xE.09F8CBp-48)) >= l_579), l_34)) == (*g_421)) <= 0xC.2133D7p+76))));
            l_600 = &g_342;
            for (g_213.f2 = 21; (g_213.f2 > 58); g_213.f2 = safe_add_func_uint16_t_u_u(g_213.f2, 8))
            { /* block id: 255 */
                const uint64_t l_611 = 18446744073709551612UL;
                float l_612 = 0x9.AD8C53p-69;
                (**g_420) = ((-0x7.Fp+1) < (safe_div_func_float_f_f(((*l_582) == (((void*)0 != (*g_344)) == (safe_add_func_float_f_f((safe_add_func_float_f_f((l_609 == l_610), (*l_582))), (*l_610))))), (l_611 <= l_612))));
            }
            (*l_542) = func_2((*l_610), (*l_610), ((void*)0 != &l_386));
        }
        (*l_615) = l_613;
    }
    (**g_226) = ((safe_add_func_float_f_f(((*l_610) != ((!(((((((safe_div_func_float_f_f((***g_428), (((0x9.944544p-46 >= (safe_div_func_float_f_f((l_623 != l_623), (!(safe_add_func_float_f_f(((-(**g_420)) < (**g_226)), ((*l_610) != ((*g_49) == (void*)0)))))))) != (*g_421)) >= (*l_623)))) <= (*g_421)) > (**g_420)) != (*l_623)) != 0x8.31D755p-60) < (*l_623)) >= (*l_610))) >= 0x1.574AFDp+32)), (-0x5.9p+1))) >= (*l_623));
    for (g_42.f0 = 0; (g_42.f0 <= 19); g_42.f0 = safe_add_func_uint32_t_u_u(g_42.f0, 5))
    { /* block id: 265 */
        int32_t * const l_632 = &g_153;
        struct S1 ***l_650 = &g_489;
        struct S1 ****l_649 = &l_650;
        int64_t l_679 = 0xD017B6232C149CE2LL;
        const struct S1 l_682 = {0x567838C5L};
        int32_t ***l_698 = &l_697;
        uint64_t l_738 = 0UL;
        float l_777 = (-0x7.Ap-1);
        int32_t l_800 = 0x4A859385L;
        int32_t l_803 = 0x1D8E6388L;
        struct S1 *l_812 = &l_386;
        uint32_t l_817 = 0xE31256A9L;
        int64_t l_823 = 0xE082AD80B1C691B8LL;
        for (g_153 = 24; (g_153 > 18); g_153 = safe_sub_func_uint32_t_u_u(g_153, 8))
        { /* block id: 268 */
            int32_t **l_633 = &g_215;
            (*l_633) = l_632;
            return (*l_632);
        }
        for (l_557 = 8; (l_557 > 17); l_557 = safe_add_func_uint64_t_u_u(l_557, 7))
        { /* block id: 274 */
            float l_640 = 0xD.099B1Cp-98;
            struct S1 *** const l_643 = &g_489;
            int32_t l_644 = 0xA80D32DFL;
        }
        for (g_153 = 0; (g_153 >= (-15)); --g_153)
        { /* block id: 338 */
            int32_t **l_677 = (void*)0;
            int32_t **l_678 = &g_215;
            struct S0 *l_680 = &g_321;
            uint32_t l_681 = 0x2E92DBF2L;
            (*l_678) = l_632;
            l_681 = ((-2L) == (l_679 < (0x38054D5CL ^ ((void*)0 == l_680))));
            (***g_343) = l_682;
        }
    }
    return g_346.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_539
 * writes:
 */
inline static struct S0  func_2(float  p_3, int32_t  p_4, uint32_t  p_5)
{ /* block id: 229 */
    uint32_t l_538 = 4294967295UL;
    p_4 = l_538;
    return g_539;
}


/* ------------------------------------------ */
/* 
 * reads : g_49 g_50 g_51 g_320.f3 g_300 g_301 g_420 g_421 g_246.f0
 * writes: g_51 g_320.f3 g_301
 */
static float  func_8(uint64_t  p_9, float  p_10, float  p_11, uint32_t  p_12, int32_t  p_13)
{ /* block id: 221 */
    (**g_49) = (**g_49);
    for (g_320.f3 = 22; (g_320.f3 <= 9); --g_320.f3)
    { /* block id: 225 */
        (*g_300) = (*g_300);
    }
    return (**g_420);
}


/* ------------------------------------------ */
/* 
 * reads : g_50 g_51 g_49 g_215 g_47 g_247.f0 g_431.f3 g_497 g_227 g_67 g_420 g_421 g_503 g_342 g_343 g_344 g_156.f2 g_391.f3 g_428 g_246.f0 g_52 g_213.f1
 * writes: g_51 g_246.f0 g_504
 */
inline static uint32_t  func_14(int32_t  p_15)
{ /* block id: 203 */
    uint32_t l_496 = 0x9FB43176L;
    volatile int32_t *l_498 = &g_52;
    const struct S1 *l_514 = &g_42;
    const struct S1 **l_513 = &l_514;
    struct S0 *l_529 = &g_390;
    struct S0 **l_528 = &l_529;
    struct S0 ***l_527 = &l_528;
    struct S0 ****l_526 = &l_527;
    int32_t l_532 = 0L;
    (**g_49) = (*g_50);
    if ((0x5FCBE30F3F1F6C32LL ^ (!((*g_215) == (l_496 & (0x66C2L | g_431.f3))))))
    { /* block id: 205 */
        float ***l_501 = &g_420;
        int64_t l_502 = 0x4C71C0AFDA356D11LL;
        l_498 = g_497;
        (**g_49) = (**g_49);
        (***l_501) = (p_15 != (safe_sub_func_float_f_f((0x0.7p-1 <= (0x0.2B7456p+96 == p_15)), ((((void*)0 != l_501) >= (*g_227)) <= l_502))));
    }
    else
    { /* block id: 209 */
        p_15 = p_15;
        g_504 = g_503;
        if ((safe_add_func_int64_t_s_s(g_503.f1, (~(((safe_lshift_func_int16_t_s_u((-9L), (((!0x60A0A59EF8E0F0E9LL) <= (safe_sub_func_uint32_t_u_u(((void*)0 == l_513), (((safe_mod_func_uint64_t_u_u((safe_div_func_uint32_t_u_u((!((*g_215) == l_496)), l_496)), (safe_rshift_func_uint16_t_u_s((safe_rshift_func_uint16_t_u_u(((&l_514 == (**g_342)) != 1L), 7)), 14)))) || g_156.f2) > g_391.f3)))) <= 1L))) < l_496) < 0x670CL)))))
        { /* block id: 212 */
            struct S1 * const *l_535 = (void*)0;
            (*g_421) = (safe_div_func_float_f_f((l_526 == (void*)0), (((((safe_add_func_float_f_f(l_532, (***g_428))) <= ((((((p_15 >= (safe_div_func_float_f_f((0xB.FE4CC1p+59 >= (((void*)0 == l_535) < 0x7.10DE10p+98)), 0x0.2p+1))) >= 0x3.4DAC7Ap+92) != (*l_498)) > l_496) < 0xA.71D951p-55) == p_15)) != 0x0.01CE6Ep+23) <= (-0x6.5p-1)) > l_532)));
            (**g_49) = (*g_50);
        }
        else
        { /* block id: 215 */
            return (*l_498);
        }
    }
    (**g_49) = l_498;
    return g_213.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_390 g_391.f3 g_226 g_227 g_50 g_51 g_156.f3 g_381 g_215 g_49 g_420 g_213.f2 g_431 g_320.f1 g_321.f2 g_247.f0 g_320.f3 g_47 g_343 g_344 g_345 g_247.f1 g_42.f0 g_156.f2 g_312.f1 g_428 g_421 g_246.f0 g_478 g_300 g_301 g_153 g_213.f3
 * writes: g_391 g_215 g_51 g_47 g_247.f0 g_52 g_213.f2 g_247.f3 g_427 g_432 g_67 g_390.f2 g_345 g_489 g_301
 */
static uint32_t  func_16(uint32_t  p_17)
{ /* block id: 132 */
    struct S0 ** const *l_401 = (void*)0;
    uint64_t l_412 = 1UL;
    float ***l_419 = (void*)0;
    float ****l_418 = &l_419;
    int32_t * const l_446 = &g_47;
    g_391 = g_390;
    for (g_391.f3 = 14; (g_391.f3 == 60); g_391.f3 = safe_add_func_int64_t_s_s(g_391.f3, 1))
    { /* block id: 136 */
        int32_t l_394 = 0xDBAEF624L;
        float *l_395 = &g_247.f0;
        struct S0 ***l_397 = (void*)0;
        l_394 = 0x0E2D0E20L;
        if ((l_394 >= ((*g_226) != l_395)))
        { /* block id: 138 */
            int32_t **l_396 = &g_215;
            (*l_396) = l_395;
        }
        else
        { /* block id: 140 */
            struct S0 ****l_398 = &l_397;
            (*l_398) = l_397;
            (*g_50) = (*g_50);
        }
    }
    (*g_215) = ((((p_17 <= ((safe_sub_func_int16_t_s_s(1L, ((l_401 == (void*)0) || ((safe_rshift_func_int16_t_s_u(((p_17 < (safe_add_func_uint32_t_u_u(0xAF8DDA87L, (safe_rshift_func_int16_t_s_u((((safe_sub_func_uint64_t_u_u(p_17, (safe_sub_func_int32_t_s_s((l_412 == 0xE06A7D9DACEBCEC9LL), 4294967294UL)))) != g_156.f3) < 0x593E8A339BA4C86FLL), 14))))) & p_17), l_412)) == 0x82D6L)))) == g_381)) == p_17) ^ 0x99C50412L) | 0x513EA799C365DECALL);
    if (p_17)
    { /* block id: 146 */
        const int64_t l_413 = 0x1CA6B990DF19C7C3LL;
        (***g_49) = l_413;
    }
    else
    { /* block id: 148 */
        float *l_417 = &g_247.f0;
        float **l_416 = &l_417;
        float ***l_415 = &l_416;
        float ****l_414 = &l_415;
        int32_t *l_422 = &g_153;
        int16_t l_433 = 0L;
        int32_t **l_494 = &g_215;
        l_418 = l_414;
        (*g_50) = (**g_49);
        if ((&g_227 != g_420))
        { /* block id: 151 */
            int32_t *l_429 = &g_47;
            struct S0 *l_461 = (void*)0;
            struct S0 * const * const l_460 = &l_461;
            struct S1 **l_473 = &g_41;
            struct S1 ***l_472 = &l_473;
            struct S1 ****l_471 = &l_472;
            struct S1 *****l_470 = &l_471;
            l_422 = l_417;
            for (g_213.f2 = 0; (g_213.f2 >= 33); g_213.f2 = safe_add_func_uint64_t_u_u(g_213.f2, 3))
            { /* block id: 155 */
                for (g_247.f3 = (-6); (g_247.f3 >= 49); g_247.f3 = safe_add_func_uint32_t_u_u(g_247.f3, 1))
                { /* block id: 158 */
                    int32_t **l_430 = &g_215;
                    g_427 = &l_415;
                    (*l_430) = l_429;
                    g_432 = g_431;
                }
                (*g_215) = l_433;
            }
            if ((((safe_mod_func_int64_t_s_s(((g_320.f1 != (safe_div_func_uint32_t_u_u(p_17, g_321.f2))) > ((-1L) == (safe_add_func_int32_t_s_s((*l_422), ((safe_lshift_func_int16_t_s_s(0x5930L, (&g_300 != (void*)0))) | g_320.f3))))), p_17)) || p_17) < p_17))
            { /* block id: 165 */
                (**g_226) = l_412;
                (**g_50) = (*l_429);
            }
            else
            { /* block id: 168 */
                uint32_t l_486 = 0xA630F82AL;
                for (g_390.f2 = 0; (g_390.f2 >= 27); g_390.f2 = safe_add_func_uint64_t_u_u(g_390.f2, 1))
                { /* block id: 171 */
                    uint16_t l_455 = 0UL;
                    struct S1 **l_488 = &g_41;
                    struct S1 *** const *l_490 = &l_472;
                    struct S0 * const *l_491 = &l_461;
                    for (l_433 = (-11); (l_433 > 16); l_433 = safe_add_func_uint16_t_u_u(l_433, 7))
                    { /* block id: 174 */
                        int32_t **l_447 = &l_429;
                        (*l_447) = l_446;
                        (**g_343) = (**g_343);
                        (**g_49) = (*g_50);
                    }
                    for (p_17 = 13; (p_17 > 14); p_17 = safe_add_func_uint32_t_u_u(p_17, 1))
                    { /* block id: 181 */
                        (***g_49) = (~(g_247.f1 & ((safe_add_func_int32_t_s_s(((safe_rshift_func_uint16_t_u_u((l_455 ^ p_17), (safe_add_func_int16_t_s_s(((*l_429) & (safe_mod_func_uint16_t_u_u((((2UL & (l_460 != &g_301)) != p_17) == (safe_lshift_func_uint16_t_u_s(((((safe_lshift_func_int16_t_s_u(((*l_429) >= 0x8346D769L), g_42.f0)) >= 4L) ^ (-6L)) || p_17), 5))), g_42.f0))), p_17)))) <= p_17), 0x14B84213L)) <= g_156.f2)));
                        if ((*g_215))
                            continue;
                    }
                    if ((p_17 > ((g_381 && ((1UL & (0UL >= g_312.f1)) != (safe_sub_func_int32_t_s_s(((((safe_add_func_uint32_t_u_u(0xEE0E5AE2L, ((void*)0 != l_470))) | 0xD300L) && p_17) || 0x6CA79F1EL), 4294967288UL)))) & l_455)))
                    { /* block id: 185 */
                        struct S0 ****l_479 = (void*)0;
                        float ** const l_485 = &l_417;
                        (***l_415) = (safe_sub_func_float_f_f((safe_add_func_float_f_f(((((((***g_428) == 0x0.Ep+1) < ((g_478 != l_479) >= (safe_sub_func_float_f_f((-(**g_420)), (safe_div_func_float_f_f(((void*)0 != l_485), (p_17 <= 0x7.9857A5p+20))))))) > (*l_446)) <= (**g_420)) < l_486), p_17)), (*g_421)));
                    }
                    else
                    { /* block id: 187 */
                        struct S0 **l_487 = &l_461;
                        (*l_487) = (*l_460);
                        g_489 = l_488;
                        (*g_300) = (*g_300);
                        (**g_50) = ((((void*)0 == l_490) & l_486) ^ (l_491 != (void*)0));
                    }
                }
            }
            (*g_50) = (void*)0;
        }
        else
        { /* block id: 196 */
            int32_t *l_492 = &g_153;
            int32_t **l_493 = &l_492;
            (***g_49) = (g_390.f2 & (*l_422));
            (*l_493) = l_492;
        }
        (*l_494) = l_446;
    }
    return g_213.f3;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int64_t  func_18(uint32_t  p_19, int32_t  p_20, int64_t  p_21, struct S1  p_22, uint32_t  p_23)
{ /* block id: 129 */
    struct S0 *l_387 = (void*)0;
    struct S0 **l_388 = &l_387;
    int32_t l_389 = (-7L);
    (*l_388) = l_387;
    return l_389;
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_52 g_42.f0 g_47 g_33 g_67 g_49 g_50 g_321.f3 g_259 g_381 g_322.f3 g_153 g_382 g_215 g_320.f1
 * writes: g_33 g_50 g_47 g_153 g_51
 */
inline static uint32_t  func_25(uint16_t  p_26, int64_t  p_27, struct S1  p_28, int32_t  p_29, uint32_t  p_30)
{ /* block id: 15 */
    int64_t l_77 = 0x8F68172882C65315LL;
    int32_t * const l_99 = (void*)0;
    int32_t * const *l_98 = &l_99;
    int32_t * const **l_97 = &l_98;
    uint64_t l_100 = 0UL;
    int32_t l_339 = 0L;
    struct S1 **l_351 = &g_41;
    struct S1 * const ***l_358 = (void*)0;
    if (((6L && (~((safe_lshift_func_uint16_t_u_u(l_77, (p_30 ^ ((safe_sub_func_uint64_t_u_u(((safe_lshift_func_uint16_t_u_s(((safe_rshift_func_int16_t_s_u((((safe_mod_func_int16_t_s_s(((~(safe_add_func_int32_t_s_s((*g_51), (~(safe_mod_func_uint16_t_u_u((((((safe_add_func_int16_t_s_s((((((safe_sub_func_int16_t_s_s(((((-9L) >= (safe_unary_minus_func_int32_t_s((l_97 != (void*)0)))) ^ (l_100 | (!p_29))) && p_30), (-6L))) && (-1L)) <= 4UL) >= g_42.f0) || g_47), g_42.f0)) || p_30) <= g_42.f0) == p_29) == p_27), g_47)))))) <= g_42.f0), 0x47A0L)) <= p_30) != g_42.f0), 3)) && g_52), g_42.f0)) && g_52), g_47)) & 1L)))) & g_42.f0))) < g_42.f0))
    { /* block id: 16 */
        g_33 = p_29;
    }
    else
    { /* block id: 18 */
        float *l_102 = &g_33;
        int32_t *l_123 = &g_47;
        int32_t **l_122 = &l_123;
        int32_t ***l_121 = &l_122;
        (*l_102) = p_30;
        (*l_102) = (g_33 > ((safe_sub_func_float_f_f(((p_30 <= (safe_add_func_float_f_f(0xF.B991B7p+3, ((safe_div_func_float_f_f(((safe_add_func_float_f_f((safe_add_func_float_f_f((l_99 == l_102), (safe_sub_func_float_f_f((g_67 <= (safe_add_func_float_f_f((safe_div_func_float_f_f(((safe_add_func_float_f_f(((void*)0 != l_121), (((safe_div_func_float_f_f((safe_sub_func_float_f_f((((((safe_add_func_float_f_f(((**g_49) != (void*)0), 0x1.Dp-1)) != 0x0.Fp-1) != g_42.f0) > g_42.f0) != p_29), p_27)), 0xB.7CB2DEp+7)) < (**l_122)) <= g_47))) != 0x2.0ECAC0p+22), p_30)), g_33))), g_47)))), 0x0.1p+1)) != 0x8.A1598Dp+16), p_29)) < g_42.f0)))) <= (***l_121)), (*l_123))) > p_27));
    }
    for (l_100 = 2; (l_100 != 56); l_100 = safe_add_func_int64_t_s_s(l_100, 1))
    { /* block id: 24 */
        uint32_t l_132 = 0UL;
        const int32_t *l_133 = (void*)0;
        const int32_t **l_134 = (void*)0;
        const int32_t **l_135 = &l_133;
        if (l_132)
            break;
        (*l_135) = l_133;
    }
    for (p_28.f0 = (-30); (p_28.f0 <= 19); p_28.f0 = safe_add_func_int16_t_s_s(p_28.f0, 6))
    { /* block id: 30 */
        (*g_49) = (*g_49);
    }
    if ((p_28.f0 && (safe_rshift_func_int16_t_s_u(0xC59EL, 2))))
    { /* block id: 33 */
        int32_t **l_140 = (void*)0;
        int32_t **l_141 = (void*)0;
        int32_t *l_143 = &g_47;
        int32_t **l_142 = &l_143;
        float *l_144 = (void*)0;
        float *l_145 = (void*)0;
        float *l_146 = &g_33;
        struct S0 *l_237 = (void*)0;
        const float *l_274 = &g_213.f0;
        const float **l_273 = &l_274;
        int16_t l_310 = 0L;
        struct S1 *l_315 = &g_42;
        uint16_t l_335 = 0xD8A8L;
        int32_t l_338 = 0L;
        (*l_142) = (**l_97);
        (*l_146) = (&l_98 != (void*)0);
        for (p_30 = 11; (p_30 < 25); p_30 = safe_add_func_int16_t_s_s(p_30, 2))
        { /* block id: 38 */
            uint32_t l_168 = 7UL;
            int32_t l_203 = 0x1F5AF2B0L;
            int32_t *l_206 = (void*)0;
            float **l_228 = (void*)0;
            volatile struct S1 *****l_347 = (void*)0;
            volatile struct S1 *****l_348 = &g_342;
            for (g_47 = 0; (g_47 != (-24)); g_47 = safe_sub_func_uint16_t_u_u(g_47, 8))
            { /* block id: 41 */
                const struct S0 *l_154 = (void*)0;
                int32_t l_167 = 0x79A214A0L;
            }
        }
        (*l_146) = (safe_add_func_float_f_f((&l_315 == l_351), (safe_add_func_float_f_f(((((*l_273) == (*l_273)) >= (0x4.493797p+0 == 0xA.48F3E3p-58)) == 0x6.4AB6A0p+91), p_26))));
    }
    else
    { /* block id: 120 */
        struct S1 ***l_360 = &l_351;
        struct S1 **** const l_359 = &l_360;
        int32_t l_380 = 0L;
        int32_t *l_383 = &g_153;
        if ((safe_add_func_uint64_t_u_u((safe_add_func_uint32_t_u_u(((l_358 == l_359) != ((safe_div_func_int32_t_s_s((safe_sub_func_int16_t_s_s(((*g_49) != (void*)0), ((((0L && ((safe_sub_func_uint16_t_u_u(((safe_rshift_func_uint16_t_u_u(((((safe_add_func_int64_t_s_s((safe_lshift_func_int16_t_s_u(p_28.f0, (safe_rshift_func_int16_t_s_s((safe_mod_func_int16_t_s_s((safe_div_func_int16_t_s_s((~((0x7DBFFB3CF3B66BF3LL < ((&g_50 != (void*)0) != p_30)) < 0xD088A12AL)), g_321.f3)), l_380)), 15)))), g_259)) == g_381) <= 0x10E5DD26L) ^ g_322.f3), l_380)) >= p_26), l_380)) <= g_153)) || g_382) > 0x9E839894L) < l_380))), (*g_215))) | p_26)), (*g_215))), 0UL)))
        { /* block id: 121 */
            l_383 = (**l_97);
        }
        else
        { /* block id: 123 */
            int32_t **l_385 = &l_383;
            int32_t ***l_384 = &l_385;
            (***l_384) = (l_384 == &g_50);
            (**g_49) = (*g_50);
        }
    }
    return g_320.f1;
}


/* ------------------------------------------ */
/* 
 * reads : g_41 g_49 g_42.f0 g_50 g_51 g_52 g_47
 * writes: g_49 g_52 g_41 g_67
 */
static int64_t  func_31(uint32_t  p_32)
{ /* block id: 1 */
    int32_t l_60 = 0x1CDFFA87L;
    volatile int32_t *l_64 = &g_52;
    int32_t * const **l_65 = (void*)0;
    volatile float *l_66 = &g_67;
    g_41 = func_35(g_41, func_43((-p_32)), (18446744073709551615UL ^ (safe_unary_minus_func_uint64_t_u((safe_mod_func_uint32_t_u_u((((safe_mod_func_uint64_t_u_u((safe_mod_func_uint32_t_u_u((((65535UL ^ (l_60 || ((l_60 == (p_32 != ((~g_42.f0) && p_32))) != l_60))) || l_60) < 0xA7B48FE2L), p_32)), p_32)) <= p_32) ^ (**g_50)), g_47))))), &g_42, g_42.f0);
    l_64 = (*g_50);
    (***g_49) = ((*l_64) >= ((l_60 > ((void*)0 != l_65)) && (((&g_42 != (void*)0) != p_32) | g_42.f0)));
    (*l_66) = (*l_64);
    return (*l_64);
}


/* ------------------------------------------ */
/* 
 * reads : g_51 g_52 g_50 g_49
 * writes: g_52
 */
inline static struct S1 * func_35(struct S1 * p_36, struct S1 * p_37, uint32_t  p_38, struct S1 * p_39, uint32_t  p_40)
{ /* block id: 6 */
    int32_t l_62 = 0xC8609E00L;
    struct S1 *l_63 = &g_42;
    (**g_50) = (*g_51);
    (***g_49) = (l_62 >= 0x55375BB799E60473LL);
    return l_63;
}


/* ------------------------------------------ */
/* 
 * reads : g_49
 * writes: g_49
 */
static struct S1 * func_43(float  p_44)
{ /* block id: 2 */
    int32_t *l_46 = &g_47;
    int32_t **l_48 = &l_46;
    (*l_48) = l_46;
    g_49 = g_49;
    return &g_42;
}




/* ---------------------------------------- */
int main (void)
{
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_33;
    csmith_sink_ = g_42.f0;
    csmith_sink_ = g_47;
    csmith_sink_ = g_52;
    csmith_sink_ = g_67;
    csmith_sink_ = g_153;
    csmith_sink_ = g_156.f0;
    csmith_sink_ = g_156.f1;
    csmith_sink_ = g_156.f2;
    csmith_sink_ = g_156.f3;
    csmith_sink_ = g_213.f0;
    csmith_sink_ = g_213.f1;
    csmith_sink_ = g_213.f2;
    csmith_sink_ = g_213.f3;
    csmith_sink_ = g_246.f0;
    csmith_sink_ = g_246.f1;
    csmith_sink_ = g_246.f2;
    csmith_sink_ = g_246.f3;
    csmith_sink_ = g_247.f0;
    csmith_sink_ = g_247.f1;
    csmith_sink_ = g_247.f2;
    csmith_sink_ = g_247.f3;
    csmith_sink_ = g_259;
    csmith_sink_ = g_312.f0;
    csmith_sink_ = g_312.f1;
    csmith_sink_ = g_312.f2;
    csmith_sink_ = g_312.f3;
    csmith_sink_ = g_313.f0;
    csmith_sink_ = g_313.f1;
    csmith_sink_ = g_313.f2;
    csmith_sink_ = g_313.f3;
    csmith_sink_ = g_320.f0;
    csmith_sink_ = g_320.f1;
    csmith_sink_ = g_320.f2;
    csmith_sink_ = g_320.f3;
    csmith_sink_ = g_321.f0;
    csmith_sink_ = g_321.f1;
    csmith_sink_ = g_321.f2;
    csmith_sink_ = g_321.f3;
    csmith_sink_ = g_322.f0;
    csmith_sink_ = g_322.f1;
    csmith_sink_ = g_322.f2;
    csmith_sink_ = g_322.f3;
    csmith_sink_ = g_346.f0;
    csmith_sink_ = g_381;
    csmith_sink_ = g_382;
    csmith_sink_ = g_390.f0;
    csmith_sink_ = g_390.f1;
    csmith_sink_ = g_390.f2;
    csmith_sink_ = g_390.f3;
    csmith_sink_ = g_391.f0;
    csmith_sink_ = g_391.f1;
    csmith_sink_ = g_391.f2;
    csmith_sink_ = g_391.f3;
    csmith_sink_ = g_431.f0;
    csmith_sink_ = g_431.f1;
    csmith_sink_ = g_431.f2;
    csmith_sink_ = g_431.f3;
    csmith_sink_ = g_432.f0;
    csmith_sink_ = g_432.f1;
    csmith_sink_ = g_432.f2;
    csmith_sink_ = g_432.f3;
    csmith_sink_ = g_503.f0;
    csmith_sink_ = g_503.f1;
    csmith_sink_ = g_503.f2;
    csmith_sink_ = g_503.f3;
    csmith_sink_ = g_504.f0;
    csmith_sink_ = g_504.f1;
    csmith_sink_ = g_504.f2;
    csmith_sink_ = g_504.f3;
    csmith_sink_ = g_539.f0;
    csmith_sink_ = g_539.f1;
    csmith_sink_ = g_539.f2;
    csmith_sink_ = g_539.f3;
    csmith_sink_ = g_573.f0;
    csmith_sink_ = g_573.f1;
    csmith_sink_ = g_573.f2;
    csmith_sink_ = g_573.f3;
    csmith_sink_ = g_599;
    csmith_sink_ = g_704;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 168
   depth: 1, occurrence: 21
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 0
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 0
breakdown:
XXX full-bitfields structs in the program: 0
breakdown:
XXX times a bitfields struct's address is taken: 0
XXX times a bitfields struct on LHS: 0
XXX times a bitfields struct on RHS: 0
XXX times a single bitfield on LHS: 0
XXX times a single bitfield on RHS: 0

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 152
   depth: 2, occurrence: 22
   depth: 3, occurrence: 2
   depth: 4, occurrence: 1
   depth: 5, occurrence: 4
   depth: 8, occurrence: 3
   depth: 10, occurrence: 1
   depth: 12, occurrence: 2
   depth: 13, occurrence: 1
   depth: 14, occurrence: 1
   depth: 18, occurrence: 3
   depth: 20, occurrence: 3
   depth: 21, occurrence: 2
   depth: 29, occurrence: 1
   depth: 30, occurrence: 1
   depth: 33, occurrence: 1
   depth: 35, occurrence: 1

XXX total number of pointers: 176

XXX times a variable address is taken: 165
XXX times a pointer is dereferenced on RHS: 182
breakdown:
   depth: 1, occurrence: 122
   depth: 2, occurrence: 41
   depth: 3, occurrence: 19
XXX times a pointer is dereferenced on LHS: 128
breakdown:
   depth: 1, occurrence: 77
   depth: 2, occurrence: 36
   depth: 3, occurrence: 13
   depth: 4, occurrence: 2
XXX times a pointer is compared with null: 44
XXX times a pointer is compared with address of another variable: 14
XXX times a pointer is compared with another pointer: 16
XXX times a pointer is qualified to be dereferenced: 582

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 241
   level: 2, occurrence: 124
   level: 3, occurrence: 63
   level: 4, occurrence: 9
   level: 5, occurrence: 4
XXX number of pointers point to pointers: 112
XXX number of pointers point to scalars: 37
XXX number of pointers point to structs: 27
XXX percent of pointers has null in alias set: 29.5
XXX average alias set size: 1.16

XXX times a non-volatile is read: 900
XXX times a non-volatile is write: 360
XXX times a volatile is read: 55
XXX    times read thru a pointer: 21
XXX times a volatile is write: 29
XXX    times written thru a pointer: 26
XXX times a volatile is available for access: 333
XXX percentage of non-volatile access: 93.8

XXX forward jumps: 0
XXX backward jumps: 0

XXX stmts: 123
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 37
   depth: 1, occurrence: 31
   depth: 2, occurrence: 31
   depth: 3, occurrence: 8
   depth: 4, occurrence: 6
   depth: 5, occurrence: 10

XXX percentage a fresh-made variable is used: 22.2
XXX percentage an existing variable is used: 77.8
********************* end of statistics **********************/

