/*
 * This is a RANDOMLY GENERATED PROGRAM.
 *
 * Generator: csmith 2.3.0
 * Git version: 30dccd7
 * Options:   --no-argc --arrays --bitfields --no-checksum --no-comma-operators --no-compound-assignment --consts --no-divs --no-embedded-assigns --no-pre-incr-operator --pre-decr-operator --post-incr-operator --post-decr-operator --unary-plus-operator --jumps --no-longlong --no-int8 --no-uint8 --no-float --math64 --no-inline-function --no-muls --safe-math --no-packed-struct --paranoid --pointers --structs --no-unions --volatiles --no-volatile-pointers --const-pointers -o /project/alipour/c-testcases/swarm/tc239.c
 * Seed:      535808600
 */


#define NO_LONGLONG

#include "csmith.h"

volatile uint32_t csmith_sink_ = 0;

static long __undefined;

/* --- Struct/Union Declarations --- */
struct S0 {
   const volatile int32_t  f0;
};

struct S1 {
   unsigned f0 : 6;
   signed f1 : 1;
   unsigned f2 : 22;
};

/* --- GLOBAL VARIABLES --- */
static int32_t g_8 = 6;
static struct S1 g_18 = {0,-0,2026};
static int32_t g_71 = 0;
static int32_t *g_74 = &g_8;
static int32_t **g_73 = &g_74;
static int32_t g_85[5][1][6] = {{{2,2,2,2,2,2}},{{2,2,2,2,2,2}},{{2,2,2,2,2,2}},{{2,2,2,2,2,2}},{{2,2,2,2,2,2}}};
static struct S1 g_89 = {2,0,445};
static struct S0 g_115 = {5};/* VOLATILE GLOBAL g_115 */
static int32_t ***** const g_152 = (void*)0;
static int32_t ***g_155 = &g_73;
static int32_t ****g_154[7][8] = {{&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155},{&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155},{&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155},{&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155},{&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155},{&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155},{&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155,&g_155}};
static int32_t *****g_153[10] = {(void*)0,&g_154[5][0],&g_154[5][0],(void*)0,&g_154[5][0],&g_154[5][0],(void*)0,&g_154[5][0],&g_154[5][0],(void*)0};
static struct S1 *g_165 = &g_89;
static struct S0 g_202 = {7};/* VOLATILE GLOBAL g_202 */
static int32_t * const *g_209 = &g_74;
static const struct S0 g_222 = {0x2AAD3B0C};/* VOLATILE GLOBAL g_222 */
static const struct S0 *g_221 = &g_222;
static const int32_t *g_391 = (void*)0;
static struct S1 g_423 = {0,-0,1596};
static const struct S0 **g_465 = &g_221;
static int32_t g_482 = 1;
static volatile struct S1 g_554 = {0,0,420};/* VOLATILE GLOBAL g_554 */
static volatile struct S1 *g_553 = &g_554;
static volatile struct S1 **g_552 = &g_553;
static volatile struct S1 ***g_551 = &g_552;
static int32_t g_565 = 0xD520168D;
static struct S0 g_720 = {-1};/* VOLATILE GLOBAL g_720 */
static volatile struct S1 ****g_943[8] = {(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0};
static volatile struct S1 *****g_942 = &g_943[6];
static struct S1 **g_1136 = &g_165;
static volatile uint16_t g_1162 = 0x8C31;/* VOLATILE GLOBAL g_1162 */
static const volatile int16_t g_1207 = (-5);/* VOLATILE GLOBAL g_1207 */
static const int32_t g_1239 = 5;
static struct S1 ***g_1309 = &g_1136;
static struct S1 ****g_1308 = &g_1309;
static struct S1 *****g_1307 = &g_1308;
static volatile struct S0 **g_1314 = (void*)0;
static volatile struct S0 ***g_1313 = &g_1314;
static volatile struct S0 ****g_1312 = &g_1313;
static struct S1 *g_1359[9][10][2] = {{{&g_423,(void*)0},{&g_423,&g_89},{&g_423,(void*)0},{&g_423,&g_89},{(void*)0,(void*)0},{&g_89,&g_423},{&g_89,(void*)0},{(void*)0,&g_89},{(void*)0,&g_423},{&g_423,&g_89}},{{(void*)0,&g_18},{&g_18,(void*)0},{&g_423,&g_18},{&g_423,&g_423},{&g_89,&g_423},{&g_89,&g_423},{&g_89,&g_423},{&g_89,&g_423},{&g_89,&g_423},{&g_423,&g_18}},{{&g_423,(void*)0},{&g_18,&g_18},{(void*)0,&g_89},{&g_423,&g_423},{(void*)0,&g_89},{(void*)0,(void*)0},{&g_89,&g_423},{&g_89,(void*)0},{(void*)0,&g_89},{&g_423,(void*)0}},{{&g_423,&g_89},{&g_423,(void*)0},{&g_423,&g_89},{(void*)0,(void*)0},{&g_89,&g_423},{&g_89,(void*)0},{(void*)0,&g_89},{(void*)0,&g_423},{&g_423,&g_89},{(void*)0,&g_18}},{{&g_18,(void*)0},{&g_423,&g_18},{&g_423,&g_423},{&g_89,&g_423},{&g_89,&g_423},{&g_89,&g_423},{&g_89,&g_423},{&g_89,&g_423},{&g_423,&g_18},{&g_423,(void*)0}},{{&g_18,&g_18},{(void*)0,&g_89},{&g_423,&g_423},{(void*)0,&g_89},{(void*)0,(void*)0},{&g_89,&g_423},{&g_89,(void*)0},{(void*)0,&g_89},{&g_423,(void*)0},{&g_423,&g_89}},{{&g_423,(void*)0},{&g_423,&g_89},{(void*)0,(void*)0},{&g_89,&g_423},{&g_89,(void*)0},{(void*)0,&g_89},{(void*)0,&g_423},{&g_423,&g_89},{&g_18,&g_423},{&g_18,(void*)0}},{{&g_89,(void*)0},{&g_89,&g_423},{&g_89,&g_423},{&g_423,&g_423},{&g_18,&g_423},{&g_423,&g_423},{&g_89,&g_423},{&g_89,(void*)0},{&g_89,(void*)0},{&g_18,&g_423}},{{&g_18,&g_89},{&g_423,&g_423},{&g_89,&g_89},{(void*)0,(void*)0},{&g_423,&g_423},{&g_89,&g_18},{&g_423,&g_89},{&g_423,&g_423},{&g_423,(void*)0},{&g_423,&g_423}}};
static struct S0 g_1685 = {1};/* VOLATILE GLOBAL g_1685 */


/* --- FORWARD DECLARATIONS --- */
static struct S0  func_1(void);
static int32_t * const  func_2(int32_t * p_3, int32_t * p_4, int32_t * p_5, int32_t * const  p_6);
static int32_t * func_9(int32_t * p_10, int32_t  p_11, int16_t  p_12, struct S1  p_13);
static struct S1 * func_21(int16_t  p_22, const struct S1 * p_23, struct S1  p_24, int32_t  p_25, int16_t  p_26);
static struct S1 * func_27(uint32_t  p_28, int32_t  p_29);
static int16_t  func_34(int32_t * p_35, uint16_t  p_36, uint32_t  p_37, struct S1  p_38);
static int32_t * func_39(int32_t * const  p_40);
static int32_t * func_41(const int32_t  p_42, struct S1 * p_43, int32_t  p_44);
static int16_t  func_52(struct S1 * p_53, const int16_t  p_54, struct S1 * p_55, uint32_t  p_56, int16_t  p_57);
static struct S1 * func_58(const int16_t  p_59, struct S1 * p_60);


/* --- FUNCTIONS --- */
/* ------------------------------------------ */
/* 
 * reads : g_8 g_18 g_73 g_74 g_209 g_1685
 * writes: g_74
 */
static struct S0  func_1(void)
{ /* block id: 0 */
    int32_t *l_7 = &g_8;
    int32_t **l_1683[3];
    int32_t **l_1684 = &g_74;
    int i;
    for (i = 0; i < 3; i++)
        l_1683[i] = &l_7;
    (*l_1684) = func_2(l_7, func_9(&g_8, ((safe_rshift_func_int16_t_s_s((safe_mod_func_uint16_t_u_u(g_8, ((-1) & (*l_7)))), 0)) >= 65535U), g_8, g_18), l_7, (*g_209));
    return g_1685;
}


/* ------------------------------------------ */
/* 
 * reads :
 * writes:
 */
static int32_t * const  func_2(int32_t * p_3, int32_t * p_4, int32_t * p_5, int32_t * const  p_6)
{ /* block id: 1050 */
    return p_6;
    /* statement id: 1051 */
    //assert (func_2_rv == &g_8);
}


/* ------------------------------------------ */
/* 
 * reads : g_73 g_74
 * writes:
 */
static int32_t * func_9(int32_t * p_10, int32_t  p_11, int16_t  p_12, struct S1  p_13)
{ /* block id: 1 */
    struct S1 *l_45[8][7] = {{&g_18,&g_18,&g_18,&g_18,&g_18,&g_18,&g_18},{&g_18,&g_18,&g_18,&g_18,&g_18,&g_18,&g_18},{&g_18,&g_18,&g_18,&g_18,&g_18,&g_18,&g_18},{&g_18,&g_18,&g_18,&g_18,&g_18,&g_18,&g_18},{&g_18,&g_18,&g_18,&g_18,&g_18,&g_18,&g_18},{&g_18,&g_18,&g_18,&g_18,&g_18,&g_18,&g_18},{&g_18,&g_18,&g_18,&g_18,&g_18,&g_18,&g_18},{&g_18,&g_18,&g_18,&g_18,&g_18,&g_18,&g_18}};
    int32_t l_46 = 0;
    int32_t ** const *l_792 = &g_73;
    int32_t ** const **l_791 = &l_792;
    int i, j;
    for (p_12 = 18; (p_12 >= 23); p_12 = safe_add_func_uint16_t_u_u(p_12, 7))
    { /* block id: 4 */
        int16_t l_1499 = 0x76BF;
    }
    return (**l_792);
    /* statement id: 1049 */
    //assert (func_9_rv == &g_8);
}


/* ------------------------------------------ */
/* 
 * reads : g_85 g_1312 g_1313 g_1314 g_18.f2 g_89.f0 g_1136 g_165 g_155 g_73 g_465 g_221 g_423.f2 g_74 g_8 g_1308 g_1309 g_89 g_552 g_553 g_202.f0 g_18.f1 g_18.f0 g_152 g_115.f0 g_71 g_209 g_554.f1 g_423.f0 g_222.f0 g_1239 g_1307 g_423.f1 g_554.f0 g_554.f2
 * writes: g_71 g_74 g_221 g_554 g_8 g_89 g_153 g_85 g_1308
 */
static struct S1 * func_21(int16_t  p_22, const struct S1 * p_23, struct S1  p_24, int32_t  p_25, int16_t  p_26)
{ /* block id: 950 */
    uint16_t l_1500 = 0xBAE6;
    const int32_t l_1510[1] = {0xCFFEE417};
    struct S1 *l_1515 = &g_89;
    uint16_t l_1521 = 0x60D3;
    int32_t *l_1524[6];
    uint32_t l_1576 = 1U;
    struct S1 *****l_1585[4][4] = {{&g_1308,&g_1308,(void*)0,&g_1308},{&g_1308,(void*)0,(void*)0,(void*)0},{&g_1308,&g_1308,&g_1308,(void*)0},{&g_1308,(void*)0,&g_1308,&g_1308}};
    const int32_t **l_1681 = &g_391;
    const int32_t ***l_1680 = &l_1681;
    const int32_t ****l_1679 = &l_1680;
    int i, j;
    for (i = 0; i < 6; i++)
        l_1524[i] = &g_8;
    if (((g_85[3][0][3] > l_1500) | 0xB94E))
    { /* block id: 951 */
        int32_t l_1503[2];
        struct S0 *l_1506 = &g_720;
        struct S0 **l_1505 = &l_1506;
        int i;
        for (i = 0; i < 2; i++)
            l_1503[i] = 0x8675B87B;
        if ((safe_mod_func_int32_t_s_s(l_1503[1], p_24.f2)))
        { /* block id: 952 */
            uint32_t l_1504 = 0xD32FEFFA;
            int32_t *l_1513 = &g_71;
            p_24.f1 = l_1504;
            (*l_1513) = ((l_1505 != (**g_1312)) | (((safe_sub_func_int32_t_s_s((safe_unary_minus_func_uint16_t_u((l_1510[0] > (l_1503[0] > 0xEEA0EC57)))), 5U)) < (g_18.f2 > (0x3484 || ((((safe_lshift_func_int16_t_s_u(p_24.f2, 3)) && g_89.f0) ^ g_85[3][0][3]) != 65530U)))) != p_24.f0));
        }
        else
        { /* block id: 955 */
            return (*g_1136);
            /* statement id: 956 */
            //assert (func_21_rv == &g_89);
        }
        (**g_155) = &l_1503[1];
        /* statement id: 958 */
        assert ((g_74 >= &l_1503[0] && g_74 <= &l_1503[1]));
    }
    else
    { /* block id: 959 */
        struct S1 *l_1514 = &g_89;
        int32_t ****l_1522 = &g_155;
        int32_t * const l_1523 = (void*)0;
        uint32_t l_1532 = 1U;
        (*g_465) = (*g_465);
        (**g_155) = l_1524[4];
        /* statement id: 961 */
        assert (g_74 == &g_8);
        if ((safe_sub_func_int16_t_s_s(p_24.f2, (((safe_unary_minus_func_uint32_t_u(g_423.f2)) || (safe_mod_func_int32_t_s_s((&l_1524[4] == &l_1524[4]), (safe_add_func_uint32_t_u_u((l_1532 > (****l_1522)), 0xE5CC343D))))) < 0xEC184256))))
        { /* block id: 962 */
            uint32_t l_1537 = 5U;
            uint32_t l_1543[10] = {0x8B370093,0x59E646ED,0x8B370093,0x59E646ED,0x8B370093,0x59E646ED,0x8B370093,0x59E646ED,0x8B370093,0x59E646ED};
            int i;
            (**g_552) = (****g_1308);
            (***l_1522) = (***l_1522);
            for (l_1532 = 5; (l_1532 == 60); l_1532 = safe_add_func_uint32_t_u_u(l_1532, 5))
            { /* block id: 967 */
                uint32_t l_1542 = 0xE1F43A94;
                for (g_8 = 3; (g_8 <= 9); g_8 += 1)
                { /* block id: 970 */
                    (**g_155) = (*g_73);
                    (*g_165) = (*p_23);
                    l_1543[0] = (((0x7835BB65 ^ p_24.f0) < (safe_mod_func_uint32_t_u_u(((((l_1537 == (****l_1522)) | (-1)) <= (safe_rshift_func_int16_t_s_s((g_8 != (p_25 != p_24.f0)), 10))) || (((safe_lshift_func_int16_t_s_s((p_24.f1 & l_1542), 10)) | 0x9C0F) <= (****l_1522))), l_1537))) || p_24.f2);
                    p_24 = (*l_1515);
                }
            }
            l_1515 = func_58(g_202.f0, (*g_1136));
            /* statement id: 977 */
            assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8 || g_74 == &g_71 || g_74 == 0);
            assert (l_1515 == 0 || l_1515 == &g_89);
        }
        else
        { /* block id: 978 */
            struct S1 *l_1556 = &g_423;
            (***l_1522) = (***l_1522);
            for (g_71 = 0; (g_71 < 26); g_71 = safe_add_func_uint16_t_u_u(g_71, 1))
            { /* block id: 982 */
                struct S0 *l_1551 = &g_202;
                struct S0 **l_1550 = &l_1551;
                int32_t **l_1555[4];
                int i;
                for (i = 0; i < 4; i++)
                    l_1555[i] = &g_74;
                (***l_1522) = func_39(func_41((safe_add_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u(((l_1550 == (**g_1312)) && (~((0x1A04 != ((safe_add_func_int16_t_s_s((-2), 1)) < p_26)) == 0x36CF))), p_25)), ((l_1555[1] == (**l_1522)) ^ p_24.f0))), l_1556, g_554.f1));
            }
        }
        /* facts after branching */
        assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8 || g_74 == &g_71 || g_74 == 0);
        assert (l_1515 == 0 || l_1515 == &g_89);
    }
    /* facts after branching */
    //assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8 || g_74 == &g_71 || g_74 == 0 || g_74 == dangling);
    assert (l_1515 == 0 || l_1515 == &g_89);
    if (((0xE6BCF2BF == (((safe_mod_func_int32_t_s_s(((!(((0U | (safe_add_func_int32_t_s_s(((0xA00F & (((safe_rshift_func_uint16_t_u_s(g_423.f0, (g_222.f0 & (0x90D1 || (safe_sub_func_uint32_t_u_u((safe_lshift_func_uint16_t_u_s((safe_lshift_func_uint16_t_u_u((safe_rshift_func_int16_t_s_u(g_423.f2, ((g_423.f0 != (p_24.f1 != p_22)) & g_89.f0))), 15)), 3)), l_1576)))))) || p_22) >= 5)) | g_423.f0), g_1239))) <= g_8) != p_24.f2)) == 0x91FE), p_22)) | p_25) <= 0U)) > 0xA8CFC594))
    { /* block id: 987 */
        uint32_t l_1581 = 0x943A9647;
        int32_t ****l_1582 = &g_155;
        struct S1 *****l_1584 = &g_1308;
        struct S0 *l_1598 = &g_115;
        struct S0 **l_1597 = &l_1598;
        struct S0 ***l_1596 = &l_1597;
        uint32_t l_1615 = 2U;
        uint32_t l_1632[6] = {0x590C0D95,0x590C0D95,0x590C0D95,0x590C0D95,0x590C0D95,0x590C0D95};
        struct S0 ****l_1674 = (void*)0;
        struct S0 ***** const l_1673[7] = {&l_1674,&l_1674,&l_1674,&l_1674,&l_1674,&l_1674,&l_1674};
        uint16_t l_1678 = 0xE642;
        int i;
        for (p_26 = 0; (p_26 < (-15)); p_26 = safe_sub_func_uint32_t_u_u(p_26, 5))
        { /* block id: 990 */
            const int16_t l_1609 = (-5);
            struct S1 *l_1610[8][1] = {{&g_423},{&g_89},{&g_423},{&g_89},{&g_423},{&g_89},{&g_423},{&g_89}};
            const struct S0 * const l_1640 = &g_115;
            uint32_t l_1658 = 4294967287U;
            int32_t l_1676[9][10] = {{0x63A58F61,0,0xE332B1CD,0xADB8B4A5,0xADB8B4A5,0xE332B1CD,0,0x63A58F61,0x922EAB45,1},{0x6F3E7945,0x85CFF861,0xBACF3375,0x95EC3D65,(-4),0,1,(-4),0x85CFF861,0xADB8B4A5},{0xE511002C,0x63A58F61,0xBACF3375,(-4),0xE7415C6B,(-4),0xBACF3375,0x63A58F61,0xE511002C,0xBACF3375},{0x95EC3D65,0x6F3E7945,0xE332B1CD,1,0x6F3E7945,(-1),0xADB8B4A5,0x95EC3D65,0xE34E39E3,0xBACF3375},{(-4),0xB52228AF,0xE34E39E3,0xBACF3375,0x7D3980EF,0x7D3980EF,0xBACF3375,0xE34E39E3,0xB52228AF,(-4)},{0xE34E39E3,0x9E2E4028,0xB52228AF,0xE332B1CD,0xB4D82A37,0x922EAB45,0xE34E39E3,(-4),0x922EAB45,0xB52228AF},{0x9E2E4028,(-4),0x6F3E7945,0x9E2E4028,0xB4D82A37,1,0xB4D82A37,0x9E2E4028,0x6F3E7945,(-4)},{0xB4D82A37,0xE34E39E3,(-2),0xE511002C,0x7D3980EF,(-2),(-4),0xB52228AF,0xE34E39E3,0xBACF3375},{0xE332B1CD,0x9E2E4028,0x7D3980EF,0x922EAB45,0,(-2),(-2),0,0x922EAB45,0x7D3980EF}};
            int i, j;
            if ((safe_lshift_func_uint16_t_u_u((l_1581 < (l_1582 != l_1582)), 15)))
            { /* block id: 991 */
                if (p_26)
                    break;
            }
            else
            { /* block id: 993 */
                if ((~4294967289U))
                { /* block id: 994 */
                    for (l_1581 = 0; (l_1581 <= 0); l_1581 += 1)
                    { /* block id: 997 */
                        (*g_73) = l_1524[4];
                        /* statement id: 998 */
                        assert (g_74 == &g_8);
                        (****l_1582) = p_26;
                    }
                    l_1585[0][1] = l_1584;
                }
                else
                { /* block id: 1002 */
                    (****g_1308) = (*p_23);
                }
            }
            if (((p_26 <= (safe_lshift_func_uint16_t_u_u((safe_rshift_func_uint16_t_u_s(((safe_mod_func_int16_t_s_s(0, (safe_sub_func_int32_t_s_s((((6U < (safe_add_func_uint16_t_u_u(((l_1596 == &l_1597) || (safe_rshift_func_uint16_t_u_s((safe_add_func_uint32_t_u_u((((void*)0 != (*g_1307)) < (safe_add_func_int32_t_s_s((safe_sub_func_int32_t_s_s((safe_mod_func_int16_t_s_s((g_18.f0 < (l_1609 ^ 0x5312)), 4U)), p_24.f2)), 0x8DABD766))), 1U)), 7))), g_85[3][0][3]))) || 0x10F845DA) && 0x198C), 0xF7C844D8)))) & p_22), g_423.f1)), p_25))) <= (-10)))
            { /* block id: 1006 */
                uint32_t l_1630 = 4294967295U;
                int32_t *l_1639 = &g_85[0][0][0];
                if (((4294967295U > 0xA619814A) && (((-1) > ((void*)0 != l_1610[2][0])) > ((void*)0 == (*g_1312)))))
                { /* block id: 1007 */
                    uint32_t l_1631 = 0x24AFE44A;
                    int32_t * const l_1634 = &g_482;
                    if (l_1609)
                    { /* block id: 1008 */
                        uint32_t l_1633 = 0x73CF5592;
                        int32_t **l_1635 = &g_74;
                        (*l_1635) = l_1634;
                        /* statement id: 1009 */
                        assert (g_74 == &g_482);
                    }
                    else
                    { /* block id: 1010 */
                        return (****g_1307);
                        /* statement id: 1011 */
                        //assert (func_21_rv == &g_89);
                    }
                    /* facts after branching */
                    assert (g_74 == &g_482);
                }
                else
                { /* block id: 1013 */
                    struct S1 *l_1638 = &g_423;
                    const struct S0 **l_1641 = &g_221;
                    for (l_1615 = (-23); (l_1615 >= 54); l_1615++)
                    { /* block id: 1016 */
                        (***g_1309) = (*p_23);
                        l_1638 = (****g_1307);
                        /* statement id: 1018 */
                        assert (l_1638 == &g_89);
                        (*g_73) = l_1639;
                        /* statement id: 1019 */
                        assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]));
                        (****l_1582) = 0xC3E9EB40;
                    }
                    /* facts after for loop */
                    assert (l_1638 == &g_89 || l_1638 == &g_423);
                    (*l_1641) = l_1640;
                    /* statement id: 1022 */
                    assert (g_221 == &g_115);
                }
                /* facts after branching */
                //assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8 || g_74 == &g_71 || g_74 == 0 || g_74 == dangling || g_74 == &g_482);
                assert (g_221 == &g_115 || g_221 == &g_222);
                return l_1610[2][0];
                /* statement id: 1024 */
                //assert (func_21_rv == &g_89 || func_21_rv == &g_423);
            }
            else
            { /* block id: 1025 */
                int16_t l_1644 = 0x91D0;
                struct S1 ****l_1677[5] = {&g_1309,&g_1309,&g_1309,&g_1309,&g_1309};
                int i;
                if ((safe_sub_func_int32_t_s_s(l_1609, (l_1644 & ((((&g_943[6] != &g_943[6]) && (0xB9C9 & (!p_24.f2))) <= (safe_add_func_uint16_t_u_u(((safe_sub_func_int16_t_s_s((safe_lshift_func_uint16_t_u_s((+(~(safe_sub_func_uint32_t_u_u(0xDF25E3F6, (((p_24.f2 || l_1609) == g_554.f0) < p_24.f2))))), 4)), 0x6C92)) < l_1658), g_18.f1))) == p_24.f0)))))
                { /* block id: 1026 */
                    (**g_155) = l_1524[4];
                    /* statement id: 1027 */
                    assert (g_74 == &g_8);
                }
                else
                { /* block id: 1028 */
                    const struct S1 **l_1662 = (void*)0;
                    const struct S1 ***l_1661 = &l_1662;
                    int32_t l_1665 = 0xD676B2B7;
                    if ((safe_sub_func_int16_t_s_s(0x9C12, (((((void*)0 == l_1661) && (((**g_1308) == (***l_1584)) | 1)) == (p_24.f1 && (safe_add_func_int16_t_s_s((l_1665 & g_71), g_554.f2)))) != p_24.f0))))
                    { /* block id: 1029 */
                        l_1676[7][5] = (safe_add_func_uint32_t_u_u((safe_add_func_int16_t_s_s(((~g_89.f2) < (5 && 9U)), l_1665)), (safe_add_func_int32_t_s_s(((l_1673[3] != (void*)0) | (~(g_115.f0 ^ (g_423.f0 & g_1239)))), g_18.f1))));
                        if (p_22)
                            continue;
                    }
                    else
                    { /* block id: 1032 */
                        return (***g_1308);
                        /* statement id: 1033 */
                        //assert (func_21_rv == &g_89);
                    }
                }
                (*l_1584) = l_1677[1];
                if (l_1609)
                    break;
            }
            if (p_26)
                break;
        }
        l_1678 = p_24.f1;
        p_24.f1 = ((l_1679 != (void*)0) != p_24.f0);
    }
    else
    { /* block id: 1043 */
        struct S1 *l_1682[1][8] = {{(void*)0,&g_423,(void*)0,(void*)0,&g_423,(void*)0,(void*)0,&g_423}};
        int i, j;
        return l_1682[0][4];
        /* statement id: 1044 */
        //assert (func_21_rv == 0 || func_21_rv == &g_423);
    }
    return (***g_1308);
    /* statement id: 1046 */
    //assert (func_21_rv == &g_89);
}


/* ------------------------------------------ */
/* 
 * reads : g_423.f2 g_1162 g_209 g_74 g_8 g_18.f1 g_423.f1 g_73 g_482 g_71 g_565 g_18.f0 g_155 g_423.f0 g_1207 g_551 g_552 g_553 g_165 g_89 g_1136 g_720.f0 g_1307 g_1308 g_1309
 * writes: g_74 g_71 g_554 g_89 g_482 g_8
 */
static struct S1 * func_27(uint32_t  p_28, int32_t  p_29)
{ /* block id: 744 */
    int16_t l_1142 = 0xEF76;
    int32_t *l_1163[4][6] = {{&g_71,&g_8,&g_71,&g_8,&g_71,&g_71},{(void*)0,&g_8,&g_8,(void*)0,&g_85[0][0][4],(void*)0},{(void*)0,&g_85[0][0][4],(void*)0,&g_8,&g_8,(void*)0},{&g_71,&g_71,&g_8,&g_71,&g_8,&g_71}};
    uint16_t l_1183 = 0xA7A0;
    uint32_t l_1206[9] = {0xBE3E4F80,0x3CB0ACFE,0x3CB0ACFE,0xBE3E4F80,0x3CB0ACFE,0x3CB0ACFE,0xBE3E4F80,0x3CB0ACFE,0x3CB0ACFE};
    struct S0 *l_1211 = (void*)0;
    struct S0 **l_1210 = &l_1211;
    struct S1 l_1236[4][2] = {{{6,0,2024},{6,0,2024}},{{6,0,2024},{6,0,2024}},{{6,0,2024},{6,0,2024}},{{6,0,2024},{6,0,2024}}};
    const int32_t l_1296 = 7;
    struct S0 ****l_1380 = (void*)0;
    struct S1 * const **l_1394 = (void*)0;
    int16_t l_1395 = 0;
    struct S1 **l_1489[5][7] = {{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&g_1359[7][1][0],&g_1359[7][1][0],&g_1359[7][1][0],&g_1359[7][1][0],&g_1359[7][1][0],&g_1359[7][1][0],&g_1359[7][1][0]},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0},{&g_1359[7][1][0],&g_1359[7][1][0],&g_1359[7][1][0],&g_1359[7][1][0],&g_1359[7][1][0],&g_1359[7][1][0],&g_1359[7][1][0]},{(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0,(void*)0}};
    int32_t l_1498[8][10][3] = {{{0,0,(-7)},{1,0,0},{(-6),0x1315DC0D,(-1)},{1,0xF7E8B25A,(-3)},{0xEB82D55C,(-6),(-1)},{0xD9161A14,0x9D80FF54,0},{(-7),(-3),(-7)},{0x89ACDC8E,0x9CA393D3,0xD8E5822B},{0x9D80FF54,(-1),1},{0x365DF9D6,1,0x673DACA6}},{{0,0xF7651DFE,4},{0,0x295BAABF,0x9D80FF54},{0x365DF9D6,0x92188197,(-1)},{0x9D80FF54,0xEB82D55C,0xEB82D55C},{0x89ACDC8E,0x212BC867,0},{(-7),0xD9161A14,0},{0xD9161A14,0,0x94447313},{0x9D80FF54,(-6),(-7)},{(-7),4,1},{0,0x212BC867,0xDEB53A3B}},{{0,0xD8E5822B,(-6)},{(-7),0x9D80FF54,(-1)},{0x9E225924,1,0x295BAABF},{0,(-1),0x673DACA6},{(-1),0xDEB53A3B,0x673DACA6},{0x92188197,0,0x295BAABF},{0xD8E5822B,0xD9161A14,(-1)},{(-6),1,(-6)},{(-3),0x94447313,0xDEB53A3B},{0x673DACA6,7,1}},{{5,0,(-7)},{1,0,0xF7651DFE},{5,0x92188197,0},{0x673DACA6,0,0},{(-3),(-7),0x9D80FF54},{(-6),0,0},{0xD8E5822B,(-1),7},{0x92188197,0x295BAABF,0xF35C4C66},{(-1),0x295BAABF,(-3)},{0,(-1),0}},{{0x9E225924,0,0},{(-7),(-7),0},{0,0,(-7)},{0,0x92188197,0xD9161A14},{(-7),0,0x94447313},{0x9D80FF54,0,0xD9161A14},{0x212BC867,7,(-7)},{(-1),0x94447313,0},{0xF7E8B25A,1,0},{7,0xD9161A14,0}},{{0x13DE12C1,0,(-3)},{0x1315DC0D,0xDEB53A3B,0xF35C4C66},{0x1315DC0D,(-1),7},{0x13DE12C1,1,0},{7,0x9D80FF54,0x9D80FF54},{0xF7E8B25A,0xD8E5822B,0},{(-1),0x212BC867,0},{0x212BC867,4,0xF7651DFE},{0x9D80FF54,(-6),(-7)},{(-7),4,1}},{{0,0x212BC867,0xDEB53A3B},{0,0xD8E5822B,(-6)},{(-7),0x9D80FF54,(-1)},{0x9E225924,1,0x295BAABF},{0,(-1),0x673DACA6},{(-1),0xDEB53A3B,0x673DACA6},{0x92188197,0,0x295BAABF},{0xD8E5822B,0xD9161A14,(-1)},{(-6),1,(-6)},{(-3),0x94447313,0xDEB53A3B}},{{0x673DACA6,7,1},{5,0,(-7)},{1,0,0xF7651DFE},{5,0x92188197,0},{0x673DACA6,0,0},{(-3),(-7),0x9D80FF54},{(-6),0,0},{0xD8E5822B,(-1),7},{0x92188197,0x295BAABF,0xF35C4C66},{(-1),0x295BAABF,(-3)}}};
    int i, j, k;
    if ((safe_sub_func_int32_t_s_s((safe_rshift_func_uint16_t_u_u((((l_1142 == (0xDE572A8F == (safe_sub_func_uint16_t_u_u((safe_lshift_func_uint16_t_u_s(((((((safe_mod_func_int32_t_s_s((safe_rshift_func_int16_t_s_s(((safe_rshift_func_int16_t_s_s(((0U | (safe_mod_func_int32_t_s_s((safe_lshift_func_int16_t_s_s(((((((p_28 ^ (safe_unary_minus_func_int16_t_s(l_1142))) != ((0U >= (safe_mod_func_uint32_t_u_u(((safe_rshift_func_uint16_t_u_u((g_423.f2 != (p_28 <= 1U)), l_1142)) | g_1162), p_28))) <= 1U)) | l_1142) || p_29) == (**g_209)) ^ p_28), p_28)), l_1142))) | g_423.f2), l_1142)) && g_18.f1), 14)), 4294967295U)) <= p_28) ^ 0xF28D) > 0x5629) ^ 4294967291U) && 5), l_1142)), l_1142)))) <= g_423.f1) | g_423.f1), 12)), 4294967295U)))
    { /* block id: 745 */
        struct S1 *l_1164 = (void*)0;
        int32_t l_1179 = (-1);
        int32_t *l_1180 = &g_8;
        struct S0 ** const l_1194 = (void*)0;
        int32_t l_1205[6] = {(-2),0x79232AA6,0x3E21A47E,0x3E21A47E,(-2),0x3E21A47E};
        int32_t *****l_1227 = (void*)0;
        int32_t l_1232 = 0x6EC2663F;
        uint32_t l_1233 = 0xC33BE88E;
        uint32_t l_1234 = 4294967295U;
        int i;
lbl_1186:
        (*g_73) = l_1163[0][2];
lbl_1216:
        p_29 = p_29;
lbl_1208:
        l_1180 = func_41(p_28, l_1164, (safe_sub_func_uint32_t_u_u(((((safe_rshift_func_int16_t_s_u((p_29 > ((((((safe_lshift_func_uint16_t_u_u((safe_sub_func_uint32_t_u_u(p_29, (((~(safe_add_func_uint16_t_u_u(((safe_rshift_func_int16_t_s_s((p_28 & ((((g_482 && ((((+(((void*)0 == &g_221) != (((g_423.f2 | 0) == (-10)) <= 0xFD24))) >= 0xAF0BB7FF) | p_29) == p_28)) <= p_28) || p_28) | p_29)), 7)) && g_423.f2), 0x3512))) & l_1179) > 0x3535C4FC))), l_1179)) < p_28) == 0xADE9E004) || g_1162) && p_29) == p_28)), g_71)) != p_28) ^ g_565) >= g_18.f0), p_28)));
        if ((safe_lshift_func_int16_t_s_u(((((void*)0 == &g_221) != p_28) & (0x758B && (p_29 & l_1183))), 1)))
        { /* block id: 749 */
            struct S1 **l_1187 = &l_1164;
            int32_t l_1209 = (-1);
            struct S0 **l_1212 = (void*)0;
            for (g_71 = (-21); (g_71 != (-14)); g_71 = safe_add_func_uint16_t_u_u(g_71, 7))
            { /* block id: 752 */
                struct S0 **l_1193 = (void*)0;
                int32_t l_1195 = 0x048824CC;
                const struct S1 l_1213 = {0,0,902};
                for (l_1183 = 0; (l_1183 <= 7); l_1183 += 1)
                { /* block id: 755 */
                    int i;
                    if (g_482)
                        goto lbl_1186;
                }
                for (l_1142 = 0; (l_1142 < (-29)); l_1142 = safe_sub_func_int16_t_s_s(l_1142, 4))
                { /* block id: 772 */
                    int32_t l_1200 = 0x69BC9AFE;
                    if ((safe_sub_func_uint32_t_u_u((l_1193 != l_1194), (l_1195 ^ (((((safe_sub_func_uint16_t_u_u((safe_mod_func_uint32_t_u_u((l_1200 > p_29), (0xE2B5 || ((safe_rshift_func_int16_t_s_u(p_28, (safe_lshift_func_int16_t_s_u(g_71, 6)))) & l_1205[4])))), l_1200)) != l_1206[6]) >= 0xB2B8) || g_423.f0) < 1U)))))
                    { /* block id: 773 */
                        if (g_1207)
                            break;
                    }
                    else
                    { /* block id: 775 */
                        if (l_1183)
                            goto lbl_1208;
                        if (l_1209)
                            break;
                        l_1212 = l_1210;
                        /* statement id: 778 */
                        assert (l_1212 == &l_1211);
                    }
                    (***g_551) = l_1213;
                    for (l_1195 = 0; (l_1195 < 1); l_1195++)
                    { /* block id: 783 */
                        if (l_1213.f0)
                            goto lbl_1216;
                        (**g_1136) = (*g_165);
                        p_29 = ((+g_720.f0) ^ ((&p_29 == &l_1209) == p_29));
                    }
                }
            }
            /* facts after for loop */
            assert (l_1212 == &l_1211 || l_1212 == 0);
        }
        else
        { /* block id: 790 */
            int32_t * const **l_1231 = &g_209;
            l_1234 = ((((&g_465 == (void*)0) || ((safe_add_func_int16_t_s_s(((p_29 >= p_28) ^ (safe_mod_func_int32_t_s_s((~0), ((safe_mod_func_int16_t_s_s(((safe_sub_func_int16_t_s_s((l_1227 == (void*)0), (((((safe_unary_minus_func_int16_t_s((((safe_add_func_uint16_t_u_u((p_29 <= (((l_1231 == l_1231) | 7U) <= p_28)), g_1162)) != p_28) <= p_29))) <= p_29) & 0x3840) >= 0xC983) || 5U))) != p_28), g_482)) || p_29)))), l_1232)) == p_28)) & p_29) & l_1233);
            for (g_482 = 5; (g_482 >= 0); g_482 -= 1)
            { /* block id: 794 */
                int i;
                (*g_73) = &l_1205[g_482];
                /* statement id: 795 */
                assert ((g_74 >= &l_1205[0] && g_74 <= &l_1205[5]));
                for (g_8 = 5; (g_8 >= 0); g_8 -= 1)
                { /* block id: 798 */
                    struct S1 l_1235 = {5,-0,1305};
                    (*g_553) = l_1235;
                }
            }
            /* facts after for loop */
            assert ((g_74 >= &l_1205[0] && g_74 <= &l_1205[5]) || g_74 == 0 || g_74 == &g_482 || g_74 == &g_8 || g_74 == &g_71 || (g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]));
        }
        /* facts after branching */
        assert ((g_74 >= &l_1205[0] && g_74 <= &l_1205[5]) || g_74 == 0 || g_74 == &g_482 || g_74 == &g_8 || g_74 == &g_71 || (g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]));
    }
    else
    { /* block id: 803 */
        const struct S0 ***l_1237 = &g_465;
        int32_t *l_1238 = &g_85[3][0][3];
        struct S1 ***l_1245[9][2] = {{&g_1136,&g_1136},{&g_1136,&g_1136},{&g_1136,&g_1136},{&g_1136,&g_1136},{&g_1136,&g_1136},{&g_1136,&g_1136},{&g_1136,&g_1136},{&g_1136,&g_1136},{&g_1136,&g_1136}};
        uint16_t l_1356 = 1U;
        int32_t l_1460 = (-6);
        struct S1 ** const *l_1465 = (void*)0;
        struct S1 ** const * const *l_1464[9] = {&l_1465,&l_1465,&l_1465,&l_1465,&l_1465,&l_1465,&l_1465,&l_1465,&l_1465};
        struct S1 ** const * const **l_1463 = &l_1464[0];
        int i, j;
        (***g_551) = l_1236[0][0];
        for (p_28 = 0; (p_28 <= 6); p_28 += 1)
        { /* block id: 807 */
            uint32_t l_1249[7][6] = {{0xA8EABE90,0x65CC65C4,4294967286U,0x63D084E9,0x65CC65C4,0x63D084E9},{0xA8EABE90,0x1B8A0EA3,0xA8EABE90,0x63D084E9,0x1B8A0EA3,4294967286U},{0xA8EABE90,0U,0x63D084E9,0x63D084E9,0U,0xA8EABE90},{0xA8EABE90,0x65CC65C4,4294967286U,0x63D084E9,0x65CC65C4,0x63D084E9},{0xA8EABE90,0x1B8A0EA3,0xA8EABE90,0x63D084E9,0x1B8A0EA3,4294967286U},{0xA8EABE90,0U,0x63D084E9,0x63D084E9,0U,0xA8EABE90},{0xA8EABE90,0x65CC65C4,4294967286U,0x63D084E9,0x65CC65C4,0x63D084E9}};
            struct S1 ****l_1279 = &l_1245[5][0];
            volatile struct S0 ****l_1317 = &g_1313;
            int32_t l_1345[8] = {0xB52563E6,0xB52563E6,0xB52563E6,0xB52563E6,0xB52563E6,0xB52563E6,0xB52563E6,0xB52563E6};
            int i, j;
            (*g_74) = ((void*)0 == l_1237);
            l_1238 = (*g_73);
            /* statement id: 809 */
            assert (l_1238 == &g_8);
            for (p_29 = 6; (p_29 >= 0); p_29 -= 1)
            { /* block id: 812 */
                uint32_t l_1248[8];
                struct S1 l_1288[1][8][8] = {{{{6,-0,1250},{6,0,207},{6,0,207},{6,-0,1250},{6,0,207},{6,0,207},{6,-0,1250},{6,0,207}},{{6,-0,1250},{6,-0,1250},{7,-0,1031},{6,-0,1250},{6,-0,1250},{7,-0,1031},{6,-0,1250},{6,-0,1250}},{{6,0,207},{6,-0,1250},{6,0,207},{6,0,207},{6,-0,1250},{6,0,207},{6,0,207},{6,-0,1250}},{{6,-0,1250},{6,0,207},{6,0,207},{6,-0,1250},{6,0,207},{6,0,207},{6,-0,1250},{6,0,207}},{{6,-0,1250},{6,-0,1250},{7,-0,1031},{6,-0,1250},{6,-0,1250},{7,-0,1031},{6,-0,1250},{6,-0,1250}},{{6,0,207},{6,-0,1250},{6,0,207},{6,0,207},{6,-0,1250},{6,0,207},{6,0,207},{6,-0,1250}},{{6,-0,1250},{6,0,207},{6,0,207},{6,-0,1250},{6,0,207},{6,0,207},{6,-0,1250},{6,0,207}},{{6,-0,1250},{6,-0,1250},{7,-0,1031},{6,-0,1250},{6,-0,1250},{7,-0,1031},{6,-0,1250},{6,-0,1250}}}};
                struct S1 *****l_1306 = &l_1279;
                int32_t l_1357 = 0xB43351F6;
                int32_t l_1364 = (-9);
                int i, j, k;
                for (i = 0; i < 8; i++)
                    l_1248[i] = 0U;
            }
        }
        /* facts after for loop */
        assert (l_1238 == &g_8 || (l_1238 >= &g_85[0][0][0] && l_1238 <= &g_85[4][0][5]));
        for (g_71 = 0; (g_71 <= 19); g_71 = safe_add_func_int32_t_s_s(g_71, 6))
        { /* block id: 886 */
            int16_t l_1389 = 0x5D0E;
            struct S1 ** const **l_1480[9][8] = {{(void*)0,(void*)0,(void*)0,&l_1465,(void*)0,&l_1465,&l_1465,(void*)0},{(void*)0,&l_1465,&l_1465,(void*)0,&l_1465,(void*)0,(void*)0,(void*)0},{(void*)0,&l_1465,(void*)0,&l_1465,(void*)0,(void*)0,&l_1465,&l_1465},{(void*)0,&l_1465,&l_1465,&l_1465,&l_1465,(void*)0,&l_1465,&l_1465},{&l_1465,&l_1465,&l_1465,&l_1465,&l_1465,&l_1465,&l_1465,(void*)0},{&l_1465,(void*)0,(void*)0,&l_1465,&l_1465,(void*)0,&l_1465,&l_1465},{&l_1465,(void*)0,(void*)0,&l_1465,(void*)0,&l_1465,(void*)0,(void*)0},{&l_1465,(void*)0,&l_1465,&l_1465,&l_1465,&l_1465,&l_1465,&l_1465},{(void*)0,(void*)0,&l_1465,&l_1465,&l_1465,&l_1465,&l_1465,&l_1465}};
            struct S1 ** const ***l_1479[4][3][1] = {{{&l_1480[0][1]},{&l_1480[0][1]},{&l_1480[0][1]}},{{&l_1480[0][1]},{&l_1480[0][1]},{&l_1480[0][1]}},{{&l_1480[0][1]},{&l_1480[0][1]},{&l_1480[0][1]}},{{&l_1480[0][1]},{&l_1480[0][1]},{&l_1480[0][1]}}};
            struct S1 ***l_1497 = &l_1489[1][0];
            int i, j, k;
        }
    }
    /* facts after branching */
    //assert (g_74 == dangling || g_74 == 0 || g_74 == &g_482 || g_74 == &g_8 || g_74 == &g_71 || (g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]));
    return (****g_1307);
    /* statement id: 949 */
    //assert (func_27_rv == &g_89);
}


/* ------------------------------------------ */
/* 
 * reads : g_155 g_73 g_222.f0
 * writes: g_74
 */
static int16_t  func_34(int32_t * p_35, uint16_t  p_36, uint32_t  p_37, struct S1  p_38)
{ /* block id: 498 */
    uint32_t l_793 = 4294967289U;
    int32_t **l_794 = &g_74;
    int32_t * const ***l_801 = (void*)0;
    const struct S0 *l_823[1][7] = {{&g_720,&g_202,&g_720,&g_720,&g_202,&g_720,&g_720}};
    uint16_t l_837 = 0x9290;
    struct S1 *l_838[7][2][10] = {{{(void*)0,(void*)0,&g_18,&g_18,&g_423,&g_423,(void*)0,(void*)0,&g_18,(void*)0},{&g_18,(void*)0,&g_18,(void*)0,(void*)0,&g_89,(void*)0,&g_89,(void*)0,(void*)0}},{{&g_18,(void*)0,&g_18,&g_18,(void*)0,&g_423,&g_18,&g_423,&g_18,&g_18},{&g_423,&g_18,&g_18,&g_18,(void*)0,&g_18,&g_423,&g_423,&g_18,(void*)0}},{{&g_18,&g_18,&g_18,&g_18,&g_18,(void*)0,(void*)0,&g_89,&g_18,&g_423},{&g_18,&g_423,&g_18,&g_423,(void*)0,&g_18,&g_18,(void*)0,&g_18,&g_18}},{{&g_18,&g_18,&g_18,&g_18,&g_18,(void*)0,(void*)0,&g_18,&g_18,(void*)0},{(void*)0,&g_18,&g_423,&g_18,(void*)0,(void*)0,(void*)0,&g_18,&g_18,(void*)0}},{{&g_89,&g_18,&g_18,&g_18,&g_18,&g_89,&g_423,&g_18,(void*)0,&g_18},{&g_423,(void*)0,(void*)0,(void*)0,(void*)0,&g_18,(void*)0,&g_423,&g_18,&g_423}},{{&g_423,&g_89,&g_18,&g_18,&g_18,&g_89,&g_423,&g_18,&g_89,(void*)0},{&g_89,&g_423,&g_18,&g_89,(void*)0,(void*)0,&g_18,&g_18,&g_18,&g_18}},{{(void*)0,&g_423,(void*)0,(void*)0,(void*)0,(void*)0,&g_423,(void*)0,(void*)0,(void*)0},{&g_18,&g_89,&g_423,&g_18,(void*)0,&g_18,(void*)0,(void*)0,&g_89,(void*)0}}};
    struct S1 **l_860 = &g_165;
    struct S1 ***l_859 = &l_860;
    struct S1 l_925 = {4,0,1619};
    const struct S1 *l_1002 = &l_925;
    struct S1 ****l_1121 = &l_859;
    uint16_t l_1134 = 0xA094;
    int i, j, k;
    (**g_155) = p_35;
    return g_222.f0;
}


/* ------------------------------------------ */
/* 
 * reads : g_155 g_73 g_74
 * writes:
 */
static int32_t * func_39(int32_t * const  p_40)
{ /* block id: 496 */
    return (**g_155);
    /* statement id: 497 */
    //assert (func_39_rv == &g_8 || (func_39_rv >= &g_85[0][0][0] && func_39_rv <= &g_85[4][0][5]));
}


/* ------------------------------------------ */
/* 
 * reads : g_155 g_73 g_74
 * writes:
 */
static int32_t * func_41(const int32_t  p_42, struct S1 * p_43, int32_t  p_44)
{ /* block id: 5 */
    int32_t *l_51 = &g_8;
    struct S1 *l_659 = (void*)0;
    int32_t ****l_682 = &g_155;
    int32_t l_683 = (-1);
    struct S0 *l_692 = &g_202;
    struct S0 **l_739 = &l_692;
    struct S0 ***l_738 = &l_739;
    for (p_44 = 0; (p_44 > (-23)); p_44 = safe_sub_func_int16_t_s_s(p_44, 1))
    { /* block id: 8 */
        int16_t l_336 = 0x34C8;
        int32_t ** const l_649 = &g_74;
    }
    return (**g_155);
    /* statement id: 495 */
    //assert (func_41_rv == &g_8 || (func_41_rv >= &g_85[0][0][0] && func_41_rv <= &g_85[4][0][5]) || func_41_rv == 0 || func_41_rv == &g_482 || func_41_rv == &g_71);
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_71 g_73 g_18 g_165 g_89 g_209 g_74 g_222.f0 g_85 g_115.f0 g_155 g_423 g_482 g_565 g_552 g_553 g_554 g_465 g_221
 * writes: g_8 g_71 g_74 g_89 g_391 g_465 g_482 g_221
 */
static int16_t  func_52(struct S1 * p_53, const int16_t  p_54, struct S1 * p_55, uint32_t  p_56, int16_t  p_57)
{ /* block id: 220 */
    struct S0 *l_338 = &g_202;
    struct S0 **l_337 = &l_338;
    struct S1 l_349 = {4,0,1889};
    int32_t ** const *l_389 = &g_73;
    int16_t l_418 = 0x52F5;
    struct S1 **l_550 = &g_165;
    struct S1 *** const l_549 = &l_550;
    const struct S0 *** const l_556 = (void*)0;
    int16_t l_566 = 0;
    uint32_t l_598 = 0x3A2E8CEB;
    if (((void*)0 == l_337))
    { /* block id: 221 */
        for (g_8 = (-10); (g_8 > (-11)); g_8 = safe_sub_func_uint16_t_u_u(g_8, 4))
        { /* block id: 224 */
            int32_t * const l_341 = &g_8;
            for (p_57 = 1; (p_57 <= 9); p_57 += 1)
            { /* block id: 227 */
                for (g_71 = 3; (g_71 <= 9); g_71 += 1)
                { /* block id: 230 */
                    int32_t **l_342 = &g_74;
                    int i;
                    (*l_342) = l_341;
                    /* statement id: 231 */
                    assert (g_74 == &g_8);
                }
            }
            if (p_54)
            { /* block id: 234 */
                uint32_t l_343[9] = {0x8FFBA570,0x8FFBA570,0x8FFBA570,0x8FFBA570,0x8FFBA570,0x8FFBA570,0x8FFBA570,0x8FFBA570,0x8FFBA570};
                int i;
                return l_343[3];
            }
            else
            { /* block id: 236 */
                for (p_56 = 8; (p_56 <= 16); p_56 = safe_add_func_int16_t_s_s(p_56, 1))
                { /* block id: 239 */
                    for (g_71 = 21; (g_71 >= 17); g_71--)
                    { /* block id: 242 */
                        int32_t *l_348[2];
                        int i;
                        for (i = 0; i < 2; i++)
                            l_348[i] = &g_85[3][0][3];
                        (*g_73) = l_348[1];
                        /* statement id: 243 */
                        assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]));
                    }
                }
                (*g_165) = (*p_55);
                return p_56;
            }
        }
    }
    else
    { /* block id: 250 */
        uint32_t l_368 = 4294967295U;
        int32_t l_379[1][9][4] = {{{0x83FFCBA9,0x85DBEB43,0xD3338343,(-1)},{0x83FFCBA9,0xD3338343,0x83FFCBA9,0xFCF9E425},{0x85DBEB43,(-1),0xFCF9E425,0xFCF9E425},{0xD3338343,0xD3338343,(-5),(-1)},{(-1),0x85DBEB43,(-5),0x85DBEB43},{0xD3338343,0x83FFCBA9,0xFCF9E425,(-5)},{0x85DBEB43,0x83FFCBA9,0x83FFCBA9,0x85DBEB43},{0x83FFCBA9,0x85DBEB43,0xD3338343,(-1)},{0x83FFCBA9,0xD3338343,0x83FFCBA9,0xFCF9E425}}};
        int32_t ** const *l_444 = &g_73;
        int32_t *****l_497 = &g_154[5][0];
        int16_t l_512 = 0x5B3E;
        uint32_t l_532 = 0x7A5CB845;
        int16_t l_537 = 2;
        int16_t l_538 = 1;
        int32_t l_574 = 0xD2FD9D4A;
        int32_t l_589 = 0x5694AB10;
        const struct S1 *l_614 = &g_423;
        const struct S1 **l_613 = &l_614;
        int i, j, k;
lbl_408:
        l_349 = (*g_165);
        if (p_56)
        { /* block id: 252 */
            int32_t l_363 = (-1);
            int32_t l_365 = (-4);
            if ((((void*)0 != (*g_209)) < p_54))
            { /* block id: 253 */
                int32_t l_360 = 3;
                int32_t l_364 = 6;
                int32_t ** const *l_387[1];
                const int32_t *l_390 = &l_379[0][7][3];
                struct S0 * const *l_401[6][5][8] = {{{&l_338,&l_338,&l_338,(void*)0,&l_338,&l_338,&l_338,&l_338},{&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,(void*)0,&l_338},{&l_338,&l_338,&l_338,&l_338,&l_338,(void*)0,&l_338,&l_338},{(void*)0,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338},{&l_338,&l_338,(void*)0,&l_338,&l_338,&l_338,&l_338,(void*)0}},{{&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338},{&l_338,&l_338,(void*)0,&l_338,&l_338,&l_338,&l_338,&l_338},{&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,(void*)0,(void*)0},{&l_338,&l_338,(void*)0,&l_338,&l_338,&l_338,&l_338,&l_338},{(void*)0,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338}},{{&l_338,&l_338,&l_338,&l_338,(void*)0,&l_338,&l_338,&l_338},{&l_338,(void*)0,&l_338,&l_338,&l_338,(void*)0,&l_338,&l_338},{(void*)0,&l_338,&l_338,(void*)0,&l_338,&l_338,&l_338,&l_338},{&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338},{&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,(void*)0,(void*)0}},{{&l_338,&l_338,(void*)0,&l_338,(void*)0,&l_338,(void*)0,&l_338},{&l_338,&l_338,&l_338,&l_338,&l_338,(void*)0,&l_338,(void*)0},{&l_338,(void*)0,(void*)0,(void*)0,&l_338,(void*)0,&l_338,(void*)0},{(void*)0,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,(void*)0},{&l_338,&l_338,&l_338,(void*)0,&l_338,(void*)0,(void*)0,&l_338}},{{(void*)0,(void*)0,&l_338,(void*)0,(void*)0,&l_338,&l_338,&l_338},{(void*)0,&l_338,&l_338,&l_338,&l_338,&l_338,(void*)0,(void*)0},{&l_338,&l_338,&l_338,&l_338,(void*)0,(void*)0,(void*)0,(void*)0},{&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338},{&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338}},{{(void*)0,&l_338,(void*)0,&l_338,&l_338,&l_338,(void*)0,&l_338},{&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,(void*)0,&l_338},{&l_338,&l_338,&l_338,(void*)0,&l_338,&l_338,(void*)0,&l_338},{&l_338,&l_338,(void*)0,&l_338,&l_338,&l_338,(void*)0,&l_338},{(void*)0,&l_338,&l_338,&l_338,&l_338,&l_338,&l_338,(void*)0}}};
                int16_t l_404[6] = {0xDD4E,0x2131,0xDD4E,0xDD4E,0x2131,0xDD4E};
                struct S1 **l_406 = (void*)0;
                struct S1 ***l_405[4][4] = {{&l_406,&l_406,&l_406,&l_406},{&l_406,&l_406,(void*)0,&l_406},{&l_406,&l_406,&l_406,&l_406},{&l_406,&l_406,&l_406,&l_406}};
                struct S1 **l_407[5] = {&g_165,&g_165,&g_165,&g_165,&g_165};
                int32_t *l_409 = &l_365;
                struct S1 l_410 = {3,-0,1115};
                struct S1 l_411 = {2,0,1938};
                int i, j, k;
                for (i = 0; i < 1; i++)
                    l_387[i] = (void*)0;
                for (g_8 = (-20); (g_8 != 0); g_8++)
                { /* block id: 256 */
                    (*g_165) = (*g_165);
                    if (g_8)
                        goto lbl_392;
                }
                l_365 = (((g_222.f0 < ((void*)0 == &g_89)) & (safe_rshift_func_uint16_t_u_s((safe_sub_func_int16_t_s_s((p_54 != (safe_sub_func_int16_t_s_s((safe_rshift_func_int16_t_s_u((l_360 <= ((safe_rshift_func_int16_t_s_u(l_363, (0xCA8C6D9C & l_360))) & l_360)), l_364)), p_56))), l_364)), p_54))) ^ p_57);
                if ((((((l_368 != (((((((((*l_337) != &g_222) < (((l_365 <= (safe_lshift_func_uint16_t_u_s((((safe_sub_func_int16_t_s_s((safe_rshift_func_int16_t_s_s((((safe_mod_func_int32_t_s_s((g_85[0][0][0] && g_115.f0), 1U)) || l_364) == g_89.f0), l_365)), p_56)) >= 0x0A541CA5) & p_56), 0))) | p_54) ^ g_18.f0)) >= 0xD830) > p_57) & 0x8B5572DA) || l_368) || g_115.f0) > p_54)) & 0x15BB) < l_364) <= g_85[3][0][3]) == 0U))
                { /* block id: 260 */
                    const int32_t *l_377 = &g_85[3][0][3];
                    int32_t *l_378[1];
                    int i;
                    for (i = 0; i < 1; i++)
                        l_378[i] = (void*)0;
                    l_379[0][7][3] = (l_377 == l_377);
                    (*g_73) = &l_360;
                    /* statement id: 262 */
                    assert (g_74 == &l_360);
                    (**g_209) = p_56;
                    for (l_363 = 0; (l_363 != (-30)); l_363--)
                    { /* block id: 266 */
                        const struct S0 **l_383[2][9][6] = {{{&g_221,&g_221,(void*)0,&g_221,&g_221,&g_221},{(void*)0,&g_221,&g_221,&g_221,&g_221,&g_221},{&g_221,&g_221,(void*)0,&g_221,(void*)0,&g_221},{&g_221,&g_221,&g_221,&g_221,&g_221,&g_221},{&g_221,&g_221,&g_221,&g_221,&g_221,&g_221},{&g_221,&g_221,&g_221,&g_221,&g_221,&g_221},{&g_221,&g_221,&g_221,&g_221,&g_221,&g_221},{&g_221,&g_221,&g_221,&g_221,&g_221,&g_221},{&g_221,&g_221,&g_221,&g_221,&g_221,&g_221}},{{&g_221,&g_221,&g_221,&g_221,&g_221,&g_221},{(void*)0,&g_221,&g_221,&g_221,&g_221,(void*)0},{&g_221,&g_221,&g_221,&g_221,&g_221,&g_221},{(void*)0,&g_221,&g_221,&g_221,&g_221,&g_221},{&g_221,&g_221,&g_221,(void*)0,(void*)0,&g_221},{&g_221,&g_221,&g_221,&g_221,&g_221,(void*)0},{&g_221,(void*)0,&g_221,&g_221,&g_221,&g_221},{&g_221,&g_221,&g_221,&g_221,&g_221,(void*)0},{&g_221,&g_221,&g_221,&g_221,&g_221,&g_221}}};
                        const struct S0 ***l_382 = &l_383[0][4][0];
                        int32_t *l_384[6][1][7] = {{{&l_379[0][2][2],&l_379[0][2][2],&g_85[2][0][0],(void*)0,&g_8,(void*)0,&g_85[2][0][0]}},{{&g_85[3][0][3],&g_85[3][0][3],&g_8,&g_71,&l_365,&g_71,&g_8}},{{&l_379[0][2][2],&l_379[0][2][2],&g_85[2][0][0],(void*)0,&g_8,(void*)0,&g_85[2][0][0]}},{{&g_85[3][0][3],&g_85[3][0][3],&g_8,&g_71,&l_365,&g_71,&g_8}},{{&l_379[0][2][2],&l_379[0][2][2],&g_85[2][0][0],(void*)0,&g_8,(void*)0,&g_85[2][0][0]}},{{&g_85[3][0][3],&g_85[3][0][3],&g_8,&g_71,&l_365,&g_71,&g_8}}};
                        int i, j, k;
                        (*l_382) = &g_221;
                        if (l_365)
                            break;
                        (**g_155) = l_384[3][0][5];
                        /* statement id: 269 */
                        assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8 || (g_74 >= &l_379[0][0][0] && g_74 <= &l_379[0][8][3]) || g_74 == &l_365 || g_74 == 0 || g_74 == &g_71);
                    }
                    /* facts after for loop */
                    assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8 || (g_74 >= &l_379[0][0][0] && g_74 <= &l_379[0][8][3]) || g_74 == &l_365 || g_74 == 0 || g_74 == &g_71 || g_74 == &l_360);
                }
                else
                { /* block id: 271 */
                    for (l_363 = 0; (l_363 < (-10)); l_363--)
                    { /* block id: 274 */
                        int32_t ** const **l_388 = (void*)0;
                        l_389 = l_387[0];
                        /* statement id: 275 */
                        assert (l_389 == 0);
                        return g_18.f0;
                        /* statement id: 276 */
                        //assert (g_74 == dangling || g_74 == &g_71 || g_74 == 0 || (g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8);
                    }
                    if ((p_57 && (l_363 > l_363)))
                    { /* block id: 278 */
lbl_392:
                        g_391 = l_390;
                        /* statement id: 279 */
                        assert ((g_391 >= &l_379[0][0][0] && g_391 <= &l_379[0][8][3]));
                        l_404[4] = ((((safe_add_func_int32_t_s_s((safe_add_func_int32_t_s_s(((0xEB5CE8C2 >= ((safe_lshift_func_int16_t_s_s((((safe_mod_func_int32_t_s_s(((p_54 & ((void*)0 == l_401[0][3][7])) > ((safe_sub_func_uint32_t_u_u(p_54, l_363)) | p_57)), (*l_390))) != (-1)) ^ p_54), 12)) == g_89.f1)) ^ 0x6EBD7AAD), g_18.f1)), 4294967286U)) == 0x1627) ^ 0x3F3E) && p_57);
                        (*g_165) = (*p_55);
                        l_407[2] = &g_165;
                    }
                    else
                    { /* block id: 284 */
                        if (p_54)
                            goto lbl_408;
                        (**g_155) = (void*)0;
                        /* statement id: 286 */
                        assert (g_74 == 0);
                        (*g_73) = l_409;
                        /* statement id: 287 */
                        assert (g_74 == &l_365);
                    }
                    /* facts after branching */
                    assert (g_74 == &l_365 || (g_74 >= &l_379[0][0][0] && g_74 <= &l_379[0][8][3]) || g_74 == &g_71 || g_74 == 0 || (g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8);
                    assert (g_391 == 0 || (g_391 >= &l_379[0][0][0] && g_391 <= &l_379[0][8][3]));
                    l_411 = l_410;
                    for (l_365 = 29; (l_365 == 11); l_365 = safe_sub_func_uint16_t_u_u(l_365, 3))
                    { /* block id: 292 */
                        return p_56;
                        /* statement id: 293 */
                        //assert (g_74 == dangling || g_74 == &g_71 || g_74 == 0 || (g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8);
                        //assert (g_391 == 0 || g_391 == dangling);
                    }
                }
                /* facts after branching */
                assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8 || (g_74 >= &l_379[0][0][0] && g_74 <= &l_379[0][8][3]) || g_74 == &l_365 || g_74 == 0 || g_74 == &g_71 || g_74 == &l_360);
                assert (g_391 == 0 || (g_391 >= &l_379[0][0][0] && g_391 <= &l_379[0][8][3]));
            }
            else
            { /* block id: 296 */
                int32_t **l_414 = (void*)0;
                int32_t **l_415 = &g_74;
lbl_466:
                (*l_415) = (*g_209);
                if ((safe_lshift_func_uint16_t_u_u((l_418 == p_54), (g_222.f0 | ((p_57 <= (~(safe_sub_func_uint32_t_u_u(((!((&g_165 == (void*)0) < 0x149A)) != g_18.f0), (p_56 > 5))))) != g_89.f0)))))
                { /* block id: 298 */
                    struct S0 *l_440 = &g_202;
                    int32_t l_441 = 9;
                    (*g_165) = g_423;
                    if ((safe_lshift_func_int16_t_s_s(((l_363 || (p_57 == p_56)) > p_56), (safe_add_func_int16_t_s_s((0xF41BC76C == (safe_sub_func_uint16_t_u_u(((((safe_rshift_func_int16_t_s_u((safe_add_func_int32_t_s_s((safe_sub_func_int32_t_s_s(((safe_lshift_func_uint16_t_u_s((((safe_sub_func_uint16_t_u_u((p_56 || (l_440 != &g_222)), ((void*)0 != (*g_73)))) > l_363) && 0x1FDE669C), 11)) | p_57), p_56)), 0xBBEADE78)), g_89.f0)) | p_56) | g_89.f0) == l_441), l_441))), p_54)))))
                    { /* block id: 300 */
                        uint32_t l_453 = 0xC37FB32B;
                        l_349.f1 = (0 != ((-2) && (((safe_lshift_func_uint16_t_u_s((((l_444 == (void*)0) || (safe_rshift_func_int16_t_s_u(0x429A, 15))) & (safe_lshift_func_uint16_t_u_s((safe_sub_func_int16_t_s_s(((0xE01A == (safe_sub_func_uint32_t_u_u((l_453 != (safe_sub_func_int32_t_s_s((safe_mod_func_uint16_t_u_u((safe_mod_func_uint16_t_u_u(((((0 | ((safe_sub_func_uint16_t_u_u((!0xF9B53902), (-7))) & l_441)) ^ 0xDE7A) != g_89.f2) ^ g_423.f1), 0xF025)), 65529U)), g_89.f1))), p_57))) < p_56), 0x5423)), 4))), 4)) ^ 7) <= 0x7356)));
                    }
                    else
                    { /* block id: 302 */
                        return p_56;
                        /* statement id: 303 */
                        //assert (g_74 == dangling || g_74 == &g_71 || g_74 == 0 || (g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8);
                    }
                    (**l_389) = &l_441;
                    /* statement id: 305 */
                    assert (g_74 == &l_441);
                }
                else
                { /* block id: 306 */
                    int32_t ***l_469 = &l_415;
                    for (g_71 = (-21); (g_71 <= (-27)); g_71 = safe_sub_func_uint32_t_u_u(g_71, 6))
                    { /* block id: 309 */
                        g_465 = &g_221;
                        if (l_418)
                            goto lbl_466;
                    }
                    if (p_54)
                    { /* block id: 313 */
                        int32_t l_470 = 0x9C1944FC;
                        (*g_73) = (**l_444);
                        l_365 = ((g_85[4][0][3] > (g_85[3][0][4] && g_115.f0)) != ((0xA079E201 > (0x85EA || ((((g_18.f1 <= (safe_rshift_func_int16_t_s_u((l_365 & (g_423.f2 < (l_469 != l_389))), 6))) == 1) >= l_470) != 0xB50E))) != 0x890295D1));
                    }
                    else
                    { /* block id: 316 */
                        int32_t *l_481 = (void*)0;
                        int32_t l_483 = (-1);
                        (**l_389) = (**l_389);
                        l_483 = (((safe_rshift_func_int16_t_s_s(((safe_add_func_uint32_t_u_u((((safe_rshift_func_int16_t_s_u((p_54 < ((p_54 > (safe_mod_func_int32_t_s_s((((safe_sub_func_uint16_t_u_u((((((g_222.f0 < (l_481 == (**l_444))) || ((((((p_56 & p_57) != (&g_221 == &l_338)) > 0x724BCA56) < 1) | g_85[2][0][1]) != 0x47287F9E)) | p_54) && p_54) != g_85[3][0][3]), p_56)) <= p_54) == p_54), 7))) > 0xCB7B1F47)), 9)) > p_54) >= g_482), l_483)) >= l_365), p_56)) >= 0x045C10A7) < g_423.f2);
                        return g_89.f0;
                        /* statement id: 319 */
                        //assert (g_74 == dangling || g_74 == &g_71 || g_74 == 0 || (g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8);
                    }
                    (**l_444) = &l_365;
                    /* statement id: 321 */
                    assert (g_74 == &l_365);
                }
                /* facts after branching */
                //assert (g_74 == &l_365 || g_74 == dangling);
            }
            /* facts after branching */
            //assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8 || (g_74 >= &l_379[0][0][0] && g_74 <= &l_379[0][8][3]) || g_74 == &l_365 || g_74 == 0 || g_74 == &g_71 || g_74 == dangling);
            assert (g_391 == 0 || (g_391 >= &l_379[0][0][0] && g_391 <= &l_379[0][8][3]));
        }
        else
        { /* block id: 324 */
            int32_t l_486 = 0x7D0DC458;
            int16_t l_489[7][8][3] = {{{7,0xE45E,0},{0,1,3},{1,0x3E58,1},{0xD2A6,0x53EC,(-8)},{0,0x8AC9,0},{(-1),0x8D92,6},{0x418C,8,0xC42A},{(-1),0x074C,(-10)}},{{0,0xE45E,0x57A3},{0xD2A6,(-2),0x53EC},{1,4,0x418C},{0,0x074C,(-8)},{7,0x3E58,6},{(-2),0x8D92,(-8)},{0xB0D8,0xCD61,0x418C},{(-1),0x53EC,0x53EC}},{{1,8,0x57A3},{0,1,(-10)},{0xB0D8,4,0xC42A},{0xD2A6,0,6},{7,4,0},{0x8D92,1,(-8)},{1,8,1},{(-2),0x53EC,3}},{{0,0xCD61,0},{0,0x8D92,0x53EC},{0x418C,0x3E58,0xC42A},{0,0x074C,0x0B24},{0,4,0x57A3},{(-2),(-2),6},{1,0xE45E,0x418C},{0x8D92,0x074C,3}},{{7,8,6},{0xD2A6,0x8D92,3},{0xB0D8,0x8AC9,0x418C},{0,0x53EC,6},{1,0x3E58,0x57A3},{(-1),1,0x0B24},{0xB0D8,(-2),4},{0x8D92,0x53EC,(-10)}},{{1,(-2),6},{0,(-2),0x074C},{0xC42A,0x8AC9,0xC42A},{0,(-10),(-9)},{1,4,6},{0x2CCA,(-1),0x0B24},{1,0xCD61,4},{0x2CCA,0,3}},{{1,(-2),0x3B36},{0,0x8D92,(-10)},{0xC42A,0x9893,1},{0,0,(-9)},{1,0x8AC9,0x57A3},{0x8D92,(-1),(-9)},{0x418C,0xE45E,1},{0x2CCA,(-10),(-10)}}};
            int32_t *l_516 = &g_8;
            struct S0 ***l_555 = (void*)0;
            struct S1 l_594 = {2,0,620};
            int16_t l_609[7] = {0xE889,0,0xE889,0xE889,0,0xE889,0xE889};
            uint32_t l_628 = 1U;
            int i, j, k;
            (*g_73) = (**l_444);
            for (g_482 = 0; (g_482 != (-18)); g_482 = safe_sub_func_int16_t_s_s(g_482, 9))
            { /* block id: 328 */
                uint32_t l_521 = 4294967290U;
                const int32_t ***l_531 = (void*)0;
                struct S1 l_590 = {7,0,252};
            }
            for (l_486 = (-2); (l_486 <= 24); l_486 = safe_add_func_uint16_t_u_u(l_486, 7))
            { /* block id: 382 */
                struct S1 l_595 = {2,-0,2044};
                int16_t l_638 = (-1);
                l_595 = l_594;
                for (l_537 = 0; (l_537 == 3); l_537++)
                { /* block id: 386 */
                    uint16_t l_612 = 65526U;
                    if (l_598)
                        break;
                    (*l_516) = (g_89.f2 > ((safe_rshift_func_int16_t_s_u(((safe_lshift_func_int16_t_s_s(((-1) >= g_89.f1), 4)) > (p_54 == l_595.f2)), 6)) <= (safe_mod_func_int16_t_s_s((safe_rshift_func_int16_t_s_s(((p_57 >= ((4294967295U & (safe_add_func_int16_t_s_s((l_609[0] == (safe_sub_func_int32_t_s_s(p_57, g_565))), 65530U))) > g_89.f0)) >= l_612), 8)), p_54))));
                }
                (*g_73) = (*g_73);
                if ((l_613 == &p_53))
                { /* block id: 391 */
                    (**l_550) = (**g_552);
                    for (l_537 = 0; (l_537 >= (-6)); --l_537)
                    { /* block id: 395 */
                        if (g_18.f2)
                            goto lbl_408;
                        (**l_444) = (**l_444);
                    }
                }
                else
                { /* block id: 399 */
                    int32_t *l_617 = &l_379[0][7][3];
                    struct S0 *l_633[8];
                    int i;
                    for (i = 0; i < 8; i++)
                        l_633[i] = &g_202;
                    (**l_389) = l_617;
                    /* statement id: 400 */
                    assert ((g_74 >= &l_379[0][0][0] && g_74 <= &l_379[0][8][3]));
                    (**g_209) = ((~(g_565 > (((((safe_rshift_func_int16_t_s_s(g_423.f1, 8)) | g_423.f1) >= ((+(safe_sub_func_int16_t_s_s((safe_lshift_func_int16_t_s_u((safe_rshift_func_uint16_t_u_u(p_54, 3)), 8)), ((l_628 ^ (((+((((((((safe_sub_func_uint32_t_u_u(((*l_617) >= (safe_unary_minus_func_uint32_t_u((l_633[4] != (*g_465))))), (safe_add_func_uint16_t_u_u((((safe_sub_func_int16_t_s_s((((((&l_338 != (void*)0) == l_638) != g_222.f0) | (*l_516)) > p_54), 0x67D0)) < 4294967290U) == 0x824CC9C3), p_56)))) != p_56) == 0xEE91) & g_423.f2) < g_85[3][0][3]) >= g_18.f0) || 0x9331E9EA) >= l_638)) || 0x0D72) || p_54)) || 65527U)))) < l_595.f0)) < 65535U) && 0))) | p_54);
                }
            }
            return g_423.f2;
            /* statement id: 404 */
            //assert (g_74 == dangling || g_74 == &g_71 || g_74 == 0 || (g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8);
        }
        /* facts after branching */
        //assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8 || (g_74 >= &l_379[0][0][0] && g_74 <= &l_379[0][8][3]) || g_74 == 0 || g_74 == &g_71 || g_74 == dangling);
        assert (g_391 == 0 || (g_391 >= &l_379[0][0][0] && g_391 <= &l_379[0][8][3]));
        (*g_465) = (*g_465);
    }
    /* facts after branching */
    //assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8 || g_74 == 0 || g_74 == &g_71 || g_74 == dangling);
    //assert (g_391 == 0 || g_391 == dangling);
    return g_85[3][0][3];
}


/* ------------------------------------------ */
/* 
 * reads : g_8 g_18.f2 g_71 g_73 g_74 g_85 g_89.f2 g_18.f1 g_18.f0 g_152 g_18 g_155 g_165 g_115.f0 g_89.f1 g_209 g_89
 * writes: g_8 g_71 g_153 g_89 g_74
 */
static struct S1 * func_58(const int16_t  p_59, struct S1 * p_60)
{ /* block id: 9 */
    int32_t * const l_64[6] = {&g_8,&g_8,&g_8,&g_8,&g_8,&g_8};
    int16_t l_83 = 0;
    int32_t *** const *l_188 = (void*)0;
    int32_t * const l_320 = &g_71;
    int32_t ***l_325 = &g_73;
    struct S1 *l_333 = (void*)0;
    int i;
    if (((&g_8 == &g_8) > (safe_add_func_uint32_t_u_u((!(l_64[2] != l_64[2])), ((p_59 < ((safe_sub_func_uint16_t_u_u(0x5601, ((safe_unary_minus_func_int16_t_s(0xD913)) < (l_64[4] == &g_8)))) && 0xD1890989)) != 0U)))))
    { /* block id: 10 */
        int32_t l_70[8] = {5,5,(-1),5,5,(-1),5,5};
        const int32_t *l_111 = &g_8;
        const int32_t **l_110 = &l_111;
        int32_t ***l_119 = &g_73;
        int32_t ****l_118 = &l_119;
        int32_t l_131 = 7;
        struct S1 *l_132 = &g_18;
        const int32_t l_150 = 1;
        uint32_t l_151[1];
        const struct S0 *l_206 = &g_115;
        uint32_t l_266 = 0xF0752AFE;
        const int32_t l_283 = 8;
        int32_t l_284 = 0xD675C657;
        int i;
        for (i = 0; i < 1; i++)
            l_151[i] = 4294967288U;
        for (g_8 = 8; (g_8 < 1); --g_8)
        { /* block id: 13 */
            int32_t * const l_72 = &g_8;
            int32_t **l_76 = &g_74;
            int32_t l_130 = (-2);
            if (g_18.f2)
                break;
            for (g_71 = 7; (g_71 >= 0); g_71 -= 1)
            { /* block id: 17 */
                uint16_t l_82 = 9U;
                int32_t l_91 = 0xE9FB3884;
                struct S0 *l_114 = &g_115;
            }
            l_131 = 0x0ACBBF45;
        }
        (*l_110) = (void*)0;
        /* statement id: 59 */
        assert (l_111 == 0);
        if (((g_18.f2 || p_59) >= ((-8) ^ ((l_132 != l_132) != 0x462C2F11))))
        { /* block id: 60 */
            uint32_t l_133 = 0x5B91466E;
            (**g_73) = l_133;
        }
        else
        { /* block id: 62 */
            const struct S1 l_156 = {0,-0,1209};
            int32_t l_189 = (-1);
            int32_t l_193 = 0x209CF466;
            struct S0 *l_200 = &g_115;
            struct S0 *l_205 = &g_202;
            int32_t *l_207 = (void*)0;
            int32_t *** const *l_213 = &l_119;
            uint32_t l_282 = 0xCF235841;
            if (((p_59 <= (!(safe_lshift_func_uint16_t_u_s(((((**g_73) > 0) > (safe_sub_func_int32_t_s_s((((p_59 | (!(65534U > ((safe_add_func_int16_t_s_s((safe_unary_minus_func_int16_t_s((safe_rshift_func_int16_t_s_s(p_59, 9)))), ((safe_rshift_func_int16_t_s_u((((((safe_sub_func_uint16_t_u_u(g_85[3][0][3], (+((***l_119) != (((*g_73) != (void*)0) >= p_59))))) == l_150) && g_89.f2) & 0x1638) <= 0x32B81410), g_18.f1)) ^ p_59))) && 4294967295U)))) & p_59) < g_18.f0), 0xA72EEF0E))) > l_151[0]), g_85[3][0][3])))) <= 0U))
            { /* block id: 63 */
                struct S1 *l_157 = &g_89;
                g_153[9] = g_152;
                (*l_157) = l_156;
                (*l_157) = (*p_60);
            }
            else
            { /* block id: 67 */
                uint32_t l_174 = 3U;
                for (g_8 = (-30); (g_8 > 15); g_8 = safe_add_func_int32_t_s_s(g_8, 1))
                { /* block id: 70 */
                    int32_t *l_162 = (void*)0;
                    for (l_83 = 0; (l_83 == (-16)); l_83--)
                    { /* block id: 73 */
                        (**g_155) = l_162;
                        /* statement id: 74 */
                        assert (g_74 == 0);
                        l_131 = (safe_rshift_func_uint16_t_u_s(((void*)0 != &g_115), p_59));
                        return g_165;
                        /* statement id: 76 */
                        //assert (func_58_rv == &g_89);
                    }
                }
                (**g_73) = ((safe_add_func_int32_t_s_s((safe_lshift_func_int16_t_s_s(((0x3325B3C6 | p_59) | g_115.f0), (g_89.f1 ^ l_156.f1))), (((((safe_lshift_func_int16_t_s_s((~(-8)), ((p_59 > ((+l_174) < g_71)) <= p_59))) ^ g_85[3][0][3]) != p_59) || (-1)) > p_59))) && 0x1B15);
            }
            (**l_119) = (*g_73);
        }
    }
    else
    { /* block id: 163 */
        int32_t ***l_296 = &g_73;
        int32_t l_299 = 1;
        struct S1 l_315 = {4,0,152};
        int32_t **** const * const l_323[2] = {&g_154[6][0],&g_154[6][0]};
        int32_t **** const *l_324 = &g_154[5][0];
        int i;
lbl_322:
        for (g_71 = (-2); (g_71 < (-4)); g_71--)
        { /* block id: 166 */
            int32_t ***l_295 = &g_73;
            struct S0 *l_316 = &g_202;
            for (g_8 = 7; (g_8 >= (-12)); g_8--)
            { /* block id: 169 */
                int32_t *l_300 = &g_85[2][0][2];
                if (p_59)
                    break;
                for (l_83 = 9; (l_83 >= 0); l_83 -= 1)
                { /* block id: 173 */
                    int i;
                    l_299 = (g_18.f2 != (safe_lshift_func_int16_t_s_s((safe_sub_func_int32_t_s_s(p_59, (safe_sub_func_uint32_t_u_u((l_295 == l_296), (safe_rshift_func_uint16_t_u_s(((***l_296) != (*g_74)), 15)))))), 8)));
                    for (l_299 = 1; (l_299 <= 6); l_299 += 1)
                    { /* block id: 177 */
                        int i, j;
                        l_300 = l_300;
                    }
                    (**l_296) = (**l_295);
                }
                return p_60;
                /* statement id: 182 */
                //assert (func_58_rv == &g_18 || func_58_rv == &g_89);
            }
            (***l_295) = ((((***l_296) || (!((4294967287U || g_85[3][0][3]) | (safe_mod_func_int16_t_s_s((***l_296), (safe_mod_func_uint16_t_u_u(((1 && (((safe_sub_func_int32_t_s_s((***l_295), ((!(safe_lshift_func_uint16_t_u_u((***l_295), 3))) & (***l_296)))) && (((safe_rshift_func_uint16_t_u_s((safe_mod_func_int32_t_s_s((((*g_209) == (**l_296)) <= 7U), p_59)), p_59)) & 65531U) <= (*g_74))) | 4294967295U)) != 0xD46D), p_59))))))) == g_85[0][0][4]) ^ p_59);
            (*g_165) = l_315;
            if (p_59)
            { /* block id: 186 */
                (**g_209) = (l_316 == (void*)0);
            }
            else
            { /* block id: 188 */
                (*g_165) = (*p_60);
                for (g_8 = 9; (g_8 >= (-2)); g_8 = safe_sub_func_uint16_t_u_u(g_8, 5))
                { /* block id: 192 */
                    uint16_t l_319 = 9U;
                    if (p_59)
                    { /* block id: 193 */
                        (*g_73) = (*g_73);
                        if (g_71)
                            goto lbl_322;
                        if (l_319)
                            continue;
                    }
                    else
                    { /* block id: 196 */
                        int32_t **l_321 = &g_74;
                        if ((*g_74))
                            break;
                        (*l_321) = l_320;
                        /* statement id: 198 */
                        assert (g_74 == &g_71);
                        return p_60;
                        /* statement id: 199 */
                        //assert (func_58_rv == &g_18 || func_58_rv == &g_89);
                    }
                }
            }
        }
        l_324 = l_323[1];
        (**g_209) = (l_325 == (void*)0);
    }
    for (l_83 = (-2); (l_83 >= 29); l_83 = safe_add_func_uint16_t_u_u(l_83, 9))
    { /* block id: 210 */
        struct S0 *l_328 = (void*)0;
        int32_t l_329 = 0x5FBCA4FF;
        l_328 = l_328;
        l_329 = 0xD11D72D7;
        for (l_329 = 15; (l_329 <= 5); --l_329)
        { /* block id: 215 */
            int32_t *l_332 = &g_85[2][0][2];
            (**g_155) = l_332;
            /* statement id: 216 */
            assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]));
        }
    }
    /* facts after for loop */
    assert ((g_74 >= &g_85[0][0][0] && g_74 <= &g_85[4][0][5]) || g_74 == &g_8);
    return l_333;
    /* statement id: 219 */
    //assert (func_58_rv == 0);
}




/* ---------------------------------------- */
int main (void)
{
    int i, j, k;
    int print_hash_value = 0;
    platform_main_begin();
    func_1();
    csmith_sink_ = g_8;
    csmith_sink_ = g_18.f0;
    csmith_sink_ = g_18.f1;
    csmith_sink_ = g_18.f2;
    csmith_sink_ = g_71;
    for (i = 0; i < 5; i++)
    {
        for (j = 0; j < 1; j++)
        {
            for (k = 0; k < 6; k++)
            {
                csmith_sink_ = g_85[i][j][k];
            }
        }
    }
    csmith_sink_ = g_89.f0;
    csmith_sink_ = g_89.f1;
    csmith_sink_ = g_89.f2;
    csmith_sink_ = g_115.f0;
    csmith_sink_ = g_202.f0;
    csmith_sink_ = g_222.f0;
    csmith_sink_ = g_423.f0;
    csmith_sink_ = g_423.f1;
    csmith_sink_ = g_423.f2;
    csmith_sink_ = g_482;
    csmith_sink_ = g_554.f0;
    csmith_sink_ = g_554.f1;
    csmith_sink_ = g_554.f2;
    csmith_sink_ = g_565;
    csmith_sink_ = g_720.f0;
    csmith_sink_ = g_1162;
    csmith_sink_ = g_1207;
    csmith_sink_ = g_1239;
    csmith_sink_ = g_1685.f0;
    platform_main_end(0,0);
    return 0;
}

/************************ statistics *************************
XXX max struct depth: 1
breakdown:
   depth: 0, occurrence: 351
   depth: 1, occurrence: 24
XXX total union variables: 0

XXX non-zero bitfields defined in structs: 3
XXX zero bitfields defined in structs: 0
XXX const bitfields defined in structs: 0
XXX volatile bitfields defined in structs: 0
XXX structs with bitfields in the program: 74
breakdown:
   indirect level: 0, occurrence: 23
   indirect level: 1, occurrence: 20
   indirect level: 2, occurrence: 6
   indirect level: 3, occurrence: 11
   indirect level: 4, occurrence: 5
   indirect level: 5, occurrence: 9
XXX full-bitfields structs in the program: 23
breakdown:
   indirect level: 0, occurrence: 23
XXX times a bitfields struct's address is taken: 82
XXX times a bitfields struct on LHS: 10
XXX times a bitfields struct on RHS: 39
XXX times a single bitfield on LHS: 3
XXX times a single bitfield on RHS: 248

XXX max expression depth: 35
breakdown:
   depth: 1, occurrence: 239
   depth: 2, occurrence: 49
   depth: 3, occurrence: 6
   depth: 4, occurrence: 2
   depth: 6, occurrence: 1
   depth: 7, occurrence: 2
   depth: 8, occurrence: 2
   depth: 10, occurrence: 1
   depth: 11, occurrence: 3
   depth: 13, occurrence: 1
   depth: 14, occurrence: 2
   depth: 15, occurrence: 4
   depth: 16, occurrence: 2
   depth: 17, occurrence: 1
   depth: 18, occurrence: 1
   depth: 21, occurrence: 1
   depth: 22, occurrence: 1
   depth: 23, occurrence: 1
   depth: 25, occurrence: 3
   depth: 26, occurrence: 2
   depth: 29, occurrence: 1
   depth: 35, occurrence: 3

XXX total number of pointers: 286

XXX times a variable address is taken: 696
XXX times a pointer is dereferenced on RHS: 259
breakdown:
   depth: 1, occurrence: 153
   depth: 2, occurrence: 60
   depth: 3, occurrence: 33
   depth: 4, occurrence: 11
   depth: 5, occurrence: 2
XXX times a pointer is dereferenced on LHS: 224
breakdown:
   depth: 1, occurrence: 132
   depth: 2, occurrence: 65
   depth: 3, occurrence: 20
   depth: 4, occurrence: 7
XXX times a pointer is compared with null: 68
XXX times a pointer is compared with address of another variable: 41
XXX times a pointer is compared with another pointer: 42
XXX times a pointer is qualified to be dereferenced: 2011

XXX max dereference level: 5
breakdown:
   level: 0, occurrence: 0
   level: 1, occurrence: 464
   level: 2, occurrence: 338
   level: 3, occurrence: 185
   level: 4, occurrence: 58
   level: 5, occurrence: 32
XXX number of pointers point to pointers: 168
XXX number of pointers point to scalars: 59
XXX number of pointers point to structs: 59
XXX percent of pointers has null in alias set: 32.5
XXX average alias set size: 1.45

XXX times a non-volatile is read: 1953
XXX times a non-volatile is write: 760
XXX times a volatile is read: 65
XXX    times read thru a pointer: 6
XXX times a volatile is write: 12
XXX    times written thru a pointer: 11
XXX times a volatile is available for access: 570
XXX percentage of non-volatile access: 97.2

XXX forward jumps: 3
XXX backward jumps: 11

XXX stmts: 222
XXX max block depth: 5
breakdown:
   depth: 0, occurrence: 20
   depth: 1, occurrence: 29
   depth: 2, occurrence: 36
   depth: 3, occurrence: 38
   depth: 4, occurrence: 46
   depth: 5, occurrence: 53

XXX percentage a fresh-made variable is used: 16.6
XXX percentage an existing variable is used: 83.4
FYI: the random generator makes assumptions about the integer size. See platform.info for more details.
********************* end of statistics **********************/

